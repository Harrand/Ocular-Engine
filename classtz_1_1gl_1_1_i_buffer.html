<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: tz::gl::IBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Topaz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tz</b></li><li class="navelem"><b>gl</b></li><li class="navelem"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classtz_1_1gl_1_1_i_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tz::gl::IBuffer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__tz__gl.html">Topaz Graphics Library (tz::gl)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>tz::gl <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> Interface Buffers are the means through which you can read and manipulate data in VRAM.  
 <a href="classtz_1_1gl_1_1_i_buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tz::gl::IBuffer:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classtz_1_1gl_1_1_i_buffer.png" usemap="#tz::gl::IBuffer_map" alt=""/>
  <map id="tz::gl::IBuffer_map" name="tz::gl::IBuffer_map">
<area href="classtz_1_1gl_1_1_buffer.html" alt="tz::gl::Buffer&lt; T &gt;" shape="rect" coords="0,56,258,80"/>
<area href="classtz_1_1gl_1_1_buffer_3_01_buffer_type_1_1_shader_storage_01_4.html" alt="tz::gl::Buffer&lt; BufferType::ShaderStorage &gt;" shape="rect" coords="268,56,526,80"/>
<area href="classtz_1_1gl_1_1_buffer_3_01_buffer_type_1_1_uniform_storage_01_4.html" alt="tz::gl::Buffer&lt; BufferType::UniformStorage &gt;" shape="rect" coords="536,56,794,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac28acec8db403e756f106991402f3b8b"><td class="memItemLeft" align="right" valign="top"><a id="ac28acec8db403e756f106991402f3b8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#ac28acec8db403e756f106991402f3b8b">IBuffer</a> ()</td></tr>
<tr class="memdesc:ac28acec8db403e756f106991402f3b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a>. <br /></td></tr>
<tr class="separator:ac28acec8db403e756f106991402f3b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ba2872b63e0d8fa8c134b61d3d262f"><td class="memItemLeft" align="right" valign="top"><a id="a42ba2872b63e0d8fa8c134b61d3d262f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IBuffer</b> (const <a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a> &amp;copy)=delete</td></tr>
<tr class="separator:a42ba2872b63e0d8fa8c134b61d3d262f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868a3f29b943ef81085b1d8288b599e0"><td class="memItemLeft" align="right" valign="top"><a id="a868a3f29b943ef81085b1d8288b599e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IBuffer</b> (<a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a> &amp;&amp;move)</td></tr>
<tr class="separator:a868a3f29b943ef81085b1d8288b599e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13e34f8ee0be140e60a0cf5a6b14aa9"><td class="memItemLeft" align="right" valign="top"><a id="ac13e34f8ee0be140e60a0cf5a6b14aa9"></a>
<a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a> &amp;rhs)=delete</td></tr>
<tr class="separator:ac13e34f8ee0be140e60a0cf5a6b14aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a2637127039e374e40ca61d5dda507"><td class="memItemLeft" align="right" valign="top"><a id="ac0a2637127039e374e40ca61d5dda507"></a>
<a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classtz_1_1gl_1_1_i_buffer.html">IBuffer</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:ac0a2637127039e374e40ca61d5dda507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f33832a91a4580b3230714bea7e0da"><td class="memItemLeft" align="right" valign="top"><a id="af4f33832a91a4580b3230714bea7e0da"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af4f33832a91a4580b3230714bea7e0da">~IBuffer</a> ()</td></tr>
<tr class="memdesc:af4f33832a91a4580b3230714bea7e0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the buffer and all data that might exist alongside it. <br /></td></tr>
<tr class="separator:af4f33832a91a4580b3230714bea7e0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fde6e53eefbec93482e0598c2119b17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a1fde6e53eefbec93482e0598c2119b17">bind</a> () const =0</td></tr>
<tr class="memdesc:a1fde6e53eefbec93482e0598c2119b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the buffer.  <a href="classtz_1_1gl_1_1_i_buffer.html#a1fde6e53eefbec93482e0598c2119b17">More...</a><br /></td></tr>
<tr class="separator:a1fde6e53eefbec93482e0598c2119b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22fe6cb6d4877743e702cdff0d4c537b"><td class="memItemLeft" align="right" valign="top"><a id="a22fe6cb6d4877743e702cdff0d4c537b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a22fe6cb6d4877743e702cdff0d4c537b">unbind</a> () const =0</td></tr>
<tr class="memdesc:a22fe6cb6d4877743e702cdff0d4c537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind the buffer. <br /></td></tr>
<tr class="separator:a22fe6cb6d4877743e702cdff0d4c537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81eac7657ee1a20261f02d463236a53"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53">size</a> () const</td></tr>
<tr class="memdesc:af81eac7657ee1a20261f02d463236a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of the underlying data associated with the buffer, in bytes.  <a href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53">More...</a><br /></td></tr>
<tr class="separator:af81eac7657ee1a20261f02d463236a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723fded886188dbd05cc69056b3f2327"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a723fded886188dbd05cc69056b3f2327">empty</a> () const</td></tr>
<tr class="memdesc:a723fded886188dbd05cc69056b3f2327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether the buffer is empty or not.  <a href="classtz_1_1gl_1_1_i_buffer.html#a723fded886188dbd05cc69056b3f2327">More...</a><br /></td></tr>
<tr class="separator:a723fded886188dbd05cc69056b3f2327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a080435df10d4e0fad18e4f206abbd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a5a080435df10d4e0fad18e4f206abbd1">is_terminal</a> () const</td></tr>
<tr class="memdesc:a5a080435df10d4e0fad18e4f206abbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether the buffer is terminal or not.  <a href="classtz_1_1gl_1_1_i_buffer.html#a5a080435df10d4e0fad18e4f206abbd1">More...</a><br /></td></tr>
<tr class="separator:a5a080435df10d4e0fad18e4f206abbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3561fbb8edf9e824332bbe1c2512843f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a3561fbb8edf9e824332bbe1c2512843f">valid</a> () const</td></tr>
<tr class="memdesc:a3561fbb8edf9e824332bbe1c2512843f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether the buffer is 'valid' or not.  <a href="classtz_1_1gl_1_1_i_buffer.html#a3561fbb8edf9e824332bbe1c2512843f">More...</a><br /></td></tr>
<tr class="separator:a3561fbb8edf9e824332bbe1c2512843f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa910689dfdf2d861221784be9990e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#affa910689dfdf2d861221784be9990e4">resize</a> (std::size_t size_bytes, BufferUsage usage=BufferUsage::StaticDraw)</td></tr>
<tr class="memdesc:affa910689dfdf2d861221784be9990e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to change the size of the buffer.  <a href="classtz_1_1gl_1_1_i_buffer.html#affa910689dfdf2d861221784be9990e4">More...</a><br /></td></tr>
<tr class="separator:affa910689dfdf2d861221784be9990e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85e9dfb1a8c43d782ac0cb61f8d6643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#ae85e9dfb1a8c43d782ac0cb61f8d6643">safe_resize</a> (std::size_t size_bytes)</td></tr>
<tr class="memdesc:ae85e9dfb1a8c43d782ac0cb61f8d6643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to change the size of the buffer, whilst preserving all data within the buffer in the process.  <a href="classtz_1_1gl_1_1_i_buffer.html#ae85e9dfb1a8c43d782ac0cb61f8d6643">More...</a><br /></td></tr>
<tr class="separator:ae85e9dfb1a8c43d782ac0cb61f8d6643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557a70c82e67f4e1cf2a82769626504e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a557a70c82e67f4e1cf2a82769626504e">retrieve</a> (std::size_t offset, std::size_t size_bytes, void *input_data) const</td></tr>
<tr class="memdesc:a557a70c82e67f4e1cf2a82769626504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a subset of the data-store.  <a href="classtz_1_1gl_1_1_i_buffer.html#a557a70c82e67f4e1cf2a82769626504e">More...</a><br /></td></tr>
<tr class="separator:a557a70c82e67f4e1cf2a82769626504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335dee611a517500be4dfff064337295"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a335dee611a517500be4dfff064337295">retrieve_all</a> (void *input_data) const</td></tr>
<tr class="memdesc:a335dee611a517500be4dfff064337295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the entirety of the data-store.  <a href="classtz_1_1gl_1_1_i_buffer.html#a335dee611a517500be4dfff064337295">More...</a><br /></td></tr>
<tr class="separator:a335dee611a517500be4dfff064337295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae491382b4833baf0b343046d5229a7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#ae491382b4833baf0b343046d5229a7a6">send</a> (std::size_t offset, <a class="el" href="structtz_1_1mem_1_1_block.html">tz::mem::Block</a> output_block)</td></tr>
<tr class="memdesc:ae491382b4833baf0b343046d5229a7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a memory block to the data-store at the given offset.  <a href="classtz_1_1gl_1_1_i_buffer.html#ae491382b4833baf0b343046d5229a7a6">More...</a><br /></td></tr>
<tr class="separator:ae491382b4833baf0b343046d5229a7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492d3cb4ff7760a2d8331c8253bc1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a4492d3cb4ff7760a2d8331c8253bc1d6">send</a> (const void *output_data)</td></tr>
<tr class="memdesc:a4492d3cb4ff7760a2d8331c8253bc1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send arbitrary data to the data-store.  <a href="classtz_1_1gl_1_1_i_buffer.html#a4492d3cb4ff7760a2d8331c8253bc1d6">More...</a><br /></td></tr>
<tr class="separator:a4492d3cb4ff7760a2d8331c8253bc1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9ccc9fa34434e3816c487ea400dca7"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:aaa9ccc9fa34434e3816c487ea400dca7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#aaa9ccc9fa34434e3816c487ea400dca7">send_range</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:aaa9ccc9fa34434e3816c487ea400dca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a range of data to the data-store.  <a href="classtz_1_1gl_1_1_i_buffer.html#aaa9ccc9fa34434e3816c487ea400dca7">More...</a><br /></td></tr>
<tr class="separator:aaa9ccc9fa34434e3816c487ea400dca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117e8b1f5b28a2bb723b3c8485bb2657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a117e8b1f5b28a2bb723b3c8485bb2657">terminal_resize</a> (std::size_t size_bytes)</td></tr>
<tr class="memdesc:a117e8b1f5b28a2bb723b3c8485bb2657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> and make it terminal.  <a href="classtz_1_1gl_1_1_i_buffer.html#a117e8b1f5b28a2bb723b3c8485bb2657">More...</a><br /></td></tr>
<tr class="separator:a117e8b1f5b28a2bb723b3c8485bb2657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4016def8193bbf2c820d45ec77f2ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#aba4016def8193bbf2c820d45ec77f2ff">make_terminal</a> ()</td></tr>
<tr class="memdesc:aba4016def8193bbf2c820d45ec77f2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> terminal without affecting its size.  <a href="classtz_1_1gl_1_1_i_buffer.html#aba4016def8193bbf2c820d45ec77f2ff">More...</a><br /></td></tr>
<tr class="separator:aba4016def8193bbf2c820d45ec77f2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f5e2d1cd87d00aca0c67e601092de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtz_1_1mem_1_1_block.html">tz::mem::Block</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#ac8f5e2d1cd87d00aca0c67e601092de8">map</a> (MappingPurpose purpose=MappingPurpose::ReadWrite)</td></tr>
<tr class="memdesc:ac8f5e2d1cd87d00aca0c67e601092de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the buffer, providing a contiguous data block that can be used from the calling code.  <a href="classtz_1_1gl_1_1_i_buffer.html#ac8f5e2d1cd87d00aca0c67e601092de8">More...</a><br /></td></tr>
<tr class="separator:ac8f5e2d1cd87d00aca0c67e601092de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e03ff9ccf8cb62dd9e5eb591f62bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a424e03ff9ccf8cb62dd9e5eb591f62bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a424e03ff9ccf8cb62dd9e5eb591f62bc">map_uniform</a> (MappingPurpose purpose=MappingPurpose::ReadWrite)</td></tr>
<tr class="memdesc:a424e03ff9ccf8cb62dd9e5eb591f62bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the buffer, providing a memory pool to be used as an array of Ts.  <a href="classtz_1_1gl_1_1_i_buffer.html#a424e03ff9ccf8cb62dd9e5eb591f62bc">More...</a><br /></td></tr>
<tr class="separator:a424e03ff9ccf8cb62dd9e5eb591f62bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e660736496a9bf253f5dca677df1ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#a2e660736496a9bf253f5dca677df1ccc">unmap</a> ()</td></tr>
<tr class="memdesc:a2e660736496a9bf253f5dca677df1ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap the buffer, saving any edits to previously mapped data and sending it back to VRAM.  <a href="classtz_1_1gl_1_1_i_buffer.html#a2e660736496a9bf253f5dca677df1ccc">More...</a><br /></td></tr>
<tr class="separator:a2e660736496a9bf253f5dca677df1ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e6906dc7ffe498834b841102d37aa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af7e6906dc7ffe498834b841102d37aa5">is_mapped</a> () const</td></tr>
<tr class="memdesc:af7e6906dc7ffe498834b841102d37aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether the buffer is currently mapped or not.  <a href="classtz_1_1gl_1_1_i_buffer.html#af7e6906dc7ffe498834b841102d37aa5">More...</a><br /></td></tr>
<tr class="separator:af7e6906dc7ffe498834b841102d37aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9253cf11cbb54d4876d35d57eb633fb6"><td class="memItemLeft" align="right" valign="top"><a id="a9253cf11cbb54d4876d35d57eb633fb6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (BufferHandle handle) const</td></tr>
<tr class="separator:a9253cf11cbb54d4876d35d57eb633fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb127889b1825fb99572c1abd3d5ef3"><td class="memItemLeft" align="right" valign="top"><a id="a8fb127889b1825fb99572c1abd3d5ef3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (BufferHandle handle) const</td></tr>
<tr class="separator:a8fb127889b1825fb99572c1abd3d5ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ad5ed6cb63910a38129f8223d0d10b6d0"><td class="memItemLeft" align="right" valign="top"><a id="ad5ed6cb63910a38129f8223d0d10b6d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#ad5ed6cb63910a38129f8223d0d10b6d0">verify</a> () const</td></tr>
<tr class="memdesc:ad5ed6cb63910a38129f8223d0d10b6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that the underlying handle is initialised. <br /></td></tr>
<tr class="separator:ad5ed6cb63910a38129f8223d0d10b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2a93f7967325e94bb5c9ec34e03989"><td class="memItemLeft" align="right" valign="top"><a id="ace2a93f7967325e94bb5c9ec34e03989"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_i_buffer.html#ace2a93f7967325e94bb5c9ec34e03989">verify_nonterminal</a> () const</td></tr>
<tr class="memdesc:ace2a93f7967325e94bb5c9ec34e03989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts that this buffer is non-terminal. <br /></td></tr>
<tr class="separator:ace2a93f7967325e94bb5c9ec34e03989"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a95483a1f4325ac6f45d51d72d99d7023"><td class="memItemLeft" align="right" valign="top"><a id="a95483a1f4325ac6f45d51d72d99d7023"></a>
BufferHandle&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="separator:a95483a1f4325ac6f45d51d72d99d7023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>tz::gl <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> Interface Buffers are the means through which you can read and manipulate data in VRAM. </p>
<p>Some Buffers require a parent <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a> to function properly &ndash; Some do not.</p>
<p>There are many different types of buffers. This class only encompasses behaviour which is shared by all buffer types. All buffers can be bound, unbound, mapped, unmapped. Note: This is not strictly true &ndash; The concept of buffer size and resizing is only available to a few buffer types. This should be refactored out. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1fde6e53eefbec93482e0598c2119b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fde6e53eefbec93482e0598c2119b17">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void tz::gl::IBuffer::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the buffer. </p>
<p>This must be done before most buffer operations. </p>

<p>Implemented in <a class="el" href="classtz_1_1gl_1_1_buffer_3_01_buffer_type_1_1_uniform_storage_01_4.html#a94ad2f719f4add12a9f21ed851495bd9">tz::gl::Buffer&lt; BufferType::UniformStorage &gt;</a>, <a class="el" href="classtz_1_1gl_1_1_buffer_3_01_buffer_type_1_1_shader_storage_01_4.html#a7400c4ee425f896ce73a8a7542c34d42">tz::gl::Buffer&lt; BufferType::ShaderStorage &gt;</a>, and <a class="el" href="classtz_1_1gl_1_1_buffer.html#a6a5bf7a847154e28ef4563f168204675">tz::gl::Buffer&lt; T &gt;</a>.</p>

</div>
</div>
<a id="a723fded886188dbd05cc69056b3f2327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723fded886188dbd05cc69056b3f2327">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tz::gl::IBuffer::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether the buffer is empty or not. </p>
<p>Buffers are empty if their size is 0 bytes.</p>
<p>Precondition: Identical to that of <a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">IBuffer::size()</a>. </p><dl class="section return"><dt>Returns</dt><dd>True if the buffer is empty, otherwise false. </dd></dl>

</div>
</div>
<a id="af7e6906dc7ffe498834b841102d37aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e6906dc7ffe498834b841102d37aa5">&#9670;&nbsp;</a></span>is_mapped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tz::gl::IBuffer::is_mapped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether the buffer is currently mapped or not. </p>
<p>Precondition: Requires the buffer to be both valid and bound. </p><dl class="section return"><dt>Returns</dt><dd>True if the buffer is mapped, otherwise false. </dd></dl>

</div>
</div>
<a id="a5a080435df10d4e0fad18e4f206abbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a080435df10d4e0fad18e4f206abbd1">&#9670;&nbsp;</a></span>is_terminal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tz::gl::IBuffer::is_terminal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether the buffer is terminal or not. </p>
<p>Buffers are terminal if their underlying storage is immutable and thus cannot be resized. Note: Once a buffer is terminal, it will remain terminal for the remainder of its lifetime. This means that any <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> can become terminal, but terminal Buffers cannot become non-terminal. Precondition: Requires the buffer to be valid. </p><dl class="section return"><dt>Returns</dt><dd>True if the buffer is terminal, otherwise false. </dd></dl>

</div>
</div>
<a id="aba4016def8193bbf2c820d45ec77f2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4016def8193bbf2c820d45ec77f2ff">&#9670;&nbsp;</a></span>make_terminal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::make_terminal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> terminal without affecting its size. </p>
<p>Precondition: Requires the buffer to be valid, bound, non-terminal and unmapped. Note: This will preserve the data within the buffer. </p>

</div>
</div>
<a id="ac8f5e2d1cd87d00aca0c67e601092de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f5e2d1cd87d00aca0c67e601092de8">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtz_1_1mem_1_1_block.html">tz::mem::Block</a> tz::gl::IBuffer::map </td>
          <td>(</td>
          <td class="paramtype">MappingPurpose&#160;</td>
          <td class="paramname"><em>purpose</em> = <code>MappingPurpose::ReadWrite</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the buffer, providing a contiguous data block that can be used from the calling code. </p>
<p>Precondition: Requires the buffer to be valid. Note: When a buffer is mapped, the memory block is cached. If the buffer is mapped a second time without unmapping prior, the cached value is returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">purpose</td><td>Describes what the desired use for the data is. This is an optimisation measure. If you don't intend to edit the data, providing MappingPurpose::ReadOnly will be a performance boon. The default purpose allows reading + writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory Block containing arbitrary data. The properties of this data are not guaranteed to be consistent with that of normal RAM. For example, this might be order of magnitudes slower than normal RAM. </dd></dl>

</div>
</div>
<a id="a424e03ff9ccf8cb62dd9e5eb591f62bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424e03ff9ccf8cb62dd9e5eb591f62bc">&#9670;&nbsp;</a></span>map_uniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt; tz::gl::IBuffer::map_uniform </td>
          <td>(</td>
          <td class="paramtype">MappingPurpose&#160;</td>
          <td class="paramname"><em>purpose</em> = <code>MappingPurpose::ReadWrite</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the buffer, providing a memory pool to be used as an array of Ts. </p>
<p>Precondition: Requires the buffer to be valid, bound and unmapped. Note: Attempting to map a buffer twice will assert and invoke UB. Query <a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af7e6906dc7ffe498834b841102d37aa5" title="Query as to whether the buffer is currently mapped or not.">IBuffer::is_mapped()</a> to ensure that this is false before mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">purpose</td><td>Describes what the desired use for the data is. This is an optimisation measure. If you don't intend to edit the data, providing MappingPurpose::ReadOnly will be a performance boon. The default purpose allows reading + writing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Uniform Memory Pool containing uninitialised data. Even if the memory does contain valid Ts, the pool will not recognise them unless they're created via the pool. </dd></dl>

</div>
</div>
<a id="affa910689dfdf2d861221784be9990e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa910689dfdf2d861221784be9990e4">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufferUsage&#160;</td>
          <td class="paramname"><em>usage</em> = <code>BufferUsage::StaticDraw</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to change the size of the buffer. </p>
<p>Precondition: Requires the buffer to be valid, nonterminal and unmapped. Note: This will not preserve any of the data within the buffer. You should use safe_resize for that. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_bytes</td><td>Desired new size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a557a70c82e67f4e1cf2a82769626504e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557a70c82e67f4e1cf2a82769626504e">&#9670;&nbsp;</a></span>retrieve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::retrieve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>input_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a subset of the data-store. </p>
<p>Precondition: Requires the buffer to be valid. If the buffer is non-terminal, then it must also be unmapped. Precondition: offset + size_bytes must be less than this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a>. Otherwise, this will assert and invoke UB. Precondition: The memory block pointed to by input_data must have size greater than or equal to size_bytes. Otherwise, this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the beginning of the data-store, in bytes. </td></tr>
    <tr><td class="paramname">size_bytes</td><td>Size of the data-store to query, in bytes. </td></tr>
    <tr><td class="paramname">input_data</td><td>Pointer to pre-allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a335dee611a517500be4dfff064337295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335dee611a517500be4dfff064337295">&#9670;&nbsp;</a></span>retrieve_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::retrieve_all </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>input_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the entirety of the data-store. </p>
<p>Precondition: Requires the buffer to be valid. If the buffer is non-terminal, then it must also be unmapped. Precondition: The memory block pointed to by input_data must have size greater than or equal to this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a>. Otherwise, this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the beginning of the data-store, in bytes. </td></tr>
    <tr><td class="paramname">size_bytes</td><td>Size of the data-store to query, in bytes. </td></tr>
    <tr><td class="paramname">input_data</td><td>Pointer to pre-allocated memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae85e9dfb1a8c43d782ac0cb61f8d6643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85e9dfb1a8c43d782ac0cb61f8d6643">&#9670;&nbsp;</a></span>safe_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::safe_resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to change the size of the buffer, whilst preserving all data within the buffer in the process. </p>
<p>Note: You can assume that this will early-out if size_bytes is equal to this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a>. Precondition: Requires the buffer to be valid, nonterminal and unmapped. Note that it is not an error to call safe_resize on a terminal buffer if the size parameter is equal to this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a>. This behaviour is not shared by this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#affa910689dfdf2d861221784be9990e4" title="Attempt to change the size of the buffer.">resize()</a>. </p>

</div>
</div>
<a id="a4492d3cb4ff7760a2d8331c8253bc1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4492d3cb4ff7760a2d8331c8253bc1d6">&#9670;&nbsp;</a></span>send() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::send </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>output_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send arbitrary data to the data-store. </p>
<p>Note: This will keep copying data from the contiguous block pointed to by output_data until the data-store is completely full. In other words, the data pointed to by output_data should have size equal to this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a> Precondition: Requires the buffer to be valid and bound. If the buffer is non-terminal, then it must also be unmapped. Precondition: Requires output_data to point to allocated memory of size less than this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a>. Otherwise, this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output_data</td><td>Pointer to contiguous data used to re-fill the data-store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae491382b4833baf0b343046d5229a7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae491382b4833baf0b343046d5229a7a6">&#9670;&nbsp;</a></span>send() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::send </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtz_1_1mem_1_1_block.html">tz::mem::Block</a>&#160;</td>
          <td class="paramname"><em>output_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a memory block to the data-store at the given offset. </p>
<p>Note: The offset is for the destination buffer, not this source block. This will always send the entire block. Note: If the block only populates a part of the data-store, then the remainder of the data is unchanged. This means that you can freely use this to only update a part of the data-store. Precondition: Requires the buffer to be valid and bound. If the buffer is non-terminal, then it must also be unmapped. Precondition: The given memory block must have a size less than or equal to (this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a> - offset). Otherwise, this will assert and only send the portion of the data that fits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset from the beginning of the data store to send data to, in bytes. </td></tr>
    <tr><td class="paramname">output_block</td><td>Block of memory to copy to the data-store at the given offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa9ccc9fa34434e3816c487ea400dca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9ccc9fa34434e3816c487ea400dca7">&#9670;&nbsp;</a></span>send_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::send_range </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a range of data to the data-store. </p>
<p>Note: If the range only populates a part of the data-store, then the remainder of the data is unchanged. This means that you can freely use this to only update a part of the data-store. Precondition: Requires the buffer to be valid and bound. If the buffer is non-terminal, then it must also be unmapped. Precondition: Requires the distance between begin and end to be less than this-&gt;<a class="el" href="classtz_1_1gl_1_1_i_buffer.html#af81eac7657ee1a20261f02d463236a53" title="Retrieve the size of the underlying data associated with the buffer, in bytes.">size()</a>. Otherwise, this will assert and only send the data that fits. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iter</td><td>Iterator type. Usage will fail to compile if Iter does not contain an increase operator (Iter::operator++) and the typedef Iter::value_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Beginning of the range to copy to the data-store. </td></tr>
    <tr><td class="paramname">end</td><td>End of the range to copy to the data-store. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af81eac7657ee1a20261f02d463236a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81eac7657ee1a20261f02d463236a53">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tz::gl::IBuffer::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the size of the underlying data associated with the buffer, in bytes. </p>
<p>Note: This doesn't really belong in the interface. This will fail unless the BufferType is one of the following:</p><ul>
<li>BufferType::Array</li>
<li>BufferType::Index Precondition: Requires the buffer to be valid. <dl class="section return"><dt>Returns</dt><dd>Size of the buffer, in bytes. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a117e8b1f5b28a2bb723b3c8485bb2657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117e8b1f5b28a2bb723b3c8485bb2657">&#9670;&nbsp;</a></span>terminal_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::terminal_resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the size of the <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> and make it terminal. </p>
<p>Terminal Buffers are fixed-size unlike normal Buffers but have additional features which may be desireable.</p><ul>
<li>Terminal Buffers can remain mapped concurrent with render invocations. There is no requirement to unmap terminal buffers before rendering.</li>
<li>Mappings of Terminal Buffers will update VRAM-side as soon as possible, as opposed to updates only happening upon unmapping.</li>
<li>In OpenGL nomenclature, Terminal Buffers are similar to Persistent Mapped Buffers (PMB).</li>
</ul>
<p>Precondition: Requires the buffer to be valid, bound, non-terminal and unmapped. Note: This will not preserve any of the data within the buffer. You should do that yourself. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_bytes</td><td>Desired new size of the buffer, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e660736496a9bf253f5dca677df1ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e660736496a9bf253f5dca677df1ccc">&#9670;&nbsp;</a></span>unmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::IBuffer::unmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap the buffer, saving any edits to previously mapped data and sending it back to VRAM. </p>
<p>Precondition: Requires the buffer to be valid, bound and mapped. Note: This will also work for persistently-mapped-buffers (PMBs). </p>

</div>
</div>
<a id="a3561fbb8edf9e824332bbe1c2512843f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3561fbb8edf9e824332bbe1c2512843f">&#9670;&nbsp;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tz::gl::IBuffer::valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether the buffer is 'valid' or not. </p>
<p>A valid buffer is a buffer that has been bound at least once. Note: Buffers will automatically bind and unbind themselves upon construction. Thus, Buffers should always be invalid.</p>
<p>Note: This must be done before most buffer operations. </p><dl class="section return"><dt>Returns</dt><dd>True if the buffer has been bound at least once, otherwise false. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/gl/<a class="el" href="buffer_8hpp_source.html">buffer.hpp</a></li>
<li>src/gl/buffer.cpp</li>
<li>src/gl/buffer.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
