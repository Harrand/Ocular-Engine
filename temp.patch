diff --git a/demo/render/lighting_demo.cpp b/demo/render/lighting_demo.cpp
index 2493424a..c156ce48 100644
--- a/demo/render/lighting_demo.cpp
+++ b/demo/render/lighting_demo.cpp
@@ -23,53 +23,205 @@ const char *vtx_shader_src = R"glsl(
 	#version 460
 	layout (location = 0) in vec3 aPos;
 	layout (location = 1) in vec2 aTexcoord;
+    layout (location = 2) in vec3 aNormal;
+    struct MVP
+    {
+        mat4 m;
+        mat4 v;
+        mat4 p;
+    };
 	#ssbo matrices
 	{
-		mat4 mvp[512];
+		MVP mvp[512];
 	};
+    out vec3 pos;
 	out vec2 texcoord;
+    out vec3 normal;
+    out MVP cur_mvp;
 	void main()
 	{
-		gl_Position = mvp[gl_DrawID] * vec4(aPos.x, aPos.y, aPos.z, 1.0);
+        cur_mvp = mvp[gl_DrawID];
+        mat4 curMVPMatrix = cur_mvp.p * cur_mvp.v * cur_mvp.m;
+		gl_Position = curMVPMatrix * vec4(aPos.x, aPos.y, aPos.z, 1.0);
+        pos = aPos;
 		texcoord = aTexcoord;
+        normal = aNormal;
 	}
 	)glsl";
 const char *frg_shader_src = R"glsl(
 	#version 460
 	#extension GL_ARB_bindless_texture : require
 	out vec4 FragColor;
+    struct MVP
+    {
+        mat4 m;
+        mat4 v;
+        mat4 p;
+    };
+    in vec3 pos;
 	in vec2 texcoord;
+    in vec3 normal;
+    in MVP cur_mvp;
 	#ssbo texture_block
 	{
 		tz_bindless_sampler tex;
 	};
+
+    struct DirectionalLight
+    {
+        /// Direction should always be provided in cameraspace.
+        vec3 direction;
+        /// Colour should always follow RGB notation.
+        vec3 colour;
+        /// Arbitrary units, use your own range.
+        float power;
+    };
+
+    struct PointLight
+    {
+        // alignment = 16
+        //If the member is a three-component vector with components consuming N basic machine units, the base alignment is 4N
+        // Position is in cameraspace.
+        // 0
+        vec3 position; // 12 (4 bytes padding to 16)
+        vec3 colour; // 28 (4 bytes padding to 32)
+        float power; // 36
+    };
+
+	PointLight parse_light(vec3 pos, vec3 col, float pow)
+	{
+		PointLight light;
+		light.position = pos;
+		light.colour = col;
+		light.power = pow;
+		return light;
+	}
+
+    vec3 diffuse_directional(DirectionalLight light, vec3 diffuse_colour, vec3 normal_cameraspace)
+    {
+        float cos_theta = clamp(dot(normal_cameraspace, light.direction), 0.0, 1.0);
+        return diffuse_colour * light.colour * light.power * cos_theta;
+    }
+
+    vec3 diffuse(PointLight light, vec3 diffuse_colour, vec3 normal_cameraspace, vec3 position_cameraspace, vec3 eye_direction_cameraspace)
+    {
+        float distance = length(light.position - position_cameraspace);
+        DirectionalLight directional;
+        directional.direction = light.position + eye_direction_cameraspace;
+        directional.colour = light.colour;
+        directional.power = light.power;
+        return diffuse_directional(directional, diffuse_colour, normal_cameraspace) / pow(distance, 2);
+    }
+
     #ssbo lighting_block
     {
-        vec3 ambient_light;
+		vec3 ambient_light;
+        PointLight point_lights[];
     };
+
 	void main()
 	{
-		FragColor = texture(tex, texcoord) + vec4(ambient_light, 1.0);
+		vec4 col = texture(tex, texcoord);
+        vec4 ambient_col = vec4(ambient_light, 1.0);
+        vec3 normal_cameraspace = (cur_mvp.v * cur_mvp.m * vec4(normal, 0.0)).xyz;
+        vec3 position_cameraspace = (cur_mvp.v * cur_mvp.m * vec4(pos, 1.0)).xyz;
+        vec3 forward_modelspace = vec3(0.0, 0.0, -1.0);
+        vec3 forward_cameraspace = (cur_mvp.v * cur_mvp.m * vec4(forward_modelspace, 0.0)).xyz;
+		vec4 output_colour = vec4(0.0, 0.0, 0.0, 1.0);
+		PointLight cur_light = point_lights[0];
+		output_colour += vec4(diffuse(cur_light, col.xyz, normal_cameraspace, position_cameraspace, forward_cameraspace), 1.0);
+		FragColor = ambient_col + output_colour;
+
+		// Debug purposes only
+		//FragColor = vec4(cur_light.position, 1.0);
 	}
 	)glsl";
 
+constexpr std::size_t max_lights = 32;
+
+struct MVP
+{
+    tz::Mat4 m;
+    tz::Mat4 v;
+    tz::Mat4 p;
+};
+
+struct PointLight
+{
+public:
+	PointLight(tz::Vec3 position, tz::Vec3 colour, float power): position(position), colour(colour), power(power){}
+
+	tz::Vec3 position;
+	float pad0;
+	tz::Vec3 colour;
+	float power;
+
+};
+
 class LightingDemoWindow : public tz::dui::DebugWindow
 {
 public:
-    LightingDemoWindow(tz::Vec3* ambient_light): tz::dui::DebugWindow("Topaz Lighting Demo"), ambient_light(ambient_light){}
+    LightingDemoWindow(tz::Vec3* ambient_light, std::array<PointLight*, max_lights> lights): tz::dui::DebugWindow("Topaz Lighting Demo"), ambient_light(ambient_light), lights(lights){}
 
     virtual void render() override
     {
         ImGui::Begin("Topaz Lighting Demo", &this->visible);
-        ImGui::DragFloat3("Ambient Light", ambient_light->data(), 0.05f, 0.0f, 1.0f);
+        ImGui::DragFloat3("Ambient Light", ambient_light->data(), 0.01f, 0.0f, 1.0f);
+        for(std::size_t i = 0; i < max_lights; i++)
+        {
+            PointLight* light = this->lights[i];
+            if(ImGui::TreeNode((std::string{"Light "} + std::to_string(i)).c_str()))
+            {
+                ImGui::DragFloat3("Position Worldspace", light->position.data(), 0.5f, -100.0f, 100.0f);
+                ImGui::DragFloat3("Colour", light->colour.data(), 0.01f, 0.0f, 1.0f);
+                ImGui::DragFloat("Power (W)", &light->power, 1.0f, 0.0f, 10000.0f);
+                ImGui::TreePop();
+            }
+        }
         ImGui::End();
     }
 private:
     tz::Vec3* ambient_light;
+    std::array<PointLight*, max_lights> lights;
 };
 
+class SplitTransformResourceWriter
+{
+public:
+    SplitTransformResourceWriter(tz::mem::Block data): mat_writer(data){}
+    bool write(tz::Vec3 pos, tz::Vec3 rot, tz::Vec3 scale, tz::Vec3 cam_pos, tz::Vec3 cam_rot, float fov, float aspect, float near, float far)
+    {
+        tz::Mat4 model = tz::geo::model(pos, rot, scale);
+        tz::Mat4 view = tz::geo::view(cam_pos, cam_rot);
+        tz::Mat4 proj = tz::geo::perspective(fov, aspect, near, far);
+        MVP mvp{model, view, proj};
+        return this->mat_writer.write(mvp);
+    }
+
+    void reset()
+    {
+        this->mat_writer.reset();
+    }
+private:
+    tz::gl::BasicResourceWriter<MVP> mat_writer;
+};
+
+namespace tz::render
+{
+    template<>
+    class ElementWriter<tz::render::SceneElement, SplitTransformResourceWriter>
+    {
+    public:
+        static void write(SplitTransformResourceWriter& writer, const tz::render::SceneElement& ele)
+        {
+            writer.write(ele.transform.position, ele.transform.rotation, ele.transform.scale, ele.camera.position, ele.camera.rotation, ele.camera.fov, ele.camera.aspect_ratio, ele.camera.near, ele.camera.far);
+        }
+    };
+}
+
 int main()
 {
+    using MyScene = tz::render::Scene<tz::render::SceneElement, SplitTransformResourceWriter>;
 	constexpr std::size_t max_elements = 512;
 	// Minimalist Graphics Demo.
 	tz::initialise("Topaz Lighting Demo");
@@ -104,9 +256,9 @@ int main()
         tz::gl::SSBO* light_ssbo = o.get<tz::gl::BufferType::ShaderStorage>(light_ssbo_id);
 
 		tz::gl::IndexedMesh triangle;
-		triangle.vertices.push_back(tz::gl::Vertex{{{-0.5f, 0.5f, 0.0f}}, {{0.0f, 0.0f}}, {{}}, {{}}, {{}}});
-		triangle.vertices.push_back(tz::gl::Vertex{{{0.5f, 0.5f, 0.0f}}, {{1.0f, 0.0f}}, {{}}, {{}}, {{}}});
-		triangle.vertices.push_back(tz::gl::Vertex{{{0.0f, 1.5f, 0.0f}}, {{0.5f, 1.0f}}, {{}}, {{}}, {{}}});
+		triangle.vertices.push_back(tz::gl::Vertex{{{-0.5f, 0.5f, 0.0f}}, {{0.0f, 0.0f}}, {{0.0f, 0.0f, -1.0f}}, {{}}, {{}}});
+		triangle.vertices.push_back(tz::gl::Vertex{{{0.5f, 0.5f, 0.0f}}, {{1.0f, 0.0f}}, {{0.0f, 0.0f, -1.0f}}, {{}}, {{}}});
+		triangle.vertices.push_back(tz::gl::Vertex{{{0.0f, 1.5f, 0.0f}}, {{0.5f, 1.0f}}, {{0.0f, 0.0f, -1.0f}}, {{}}, {{}}});
 		triangle.indices = {0, 1, 2};
 
 		tz::gl::IndexedMesh square;
@@ -145,9 +297,9 @@ int main()
 		//tz::gl::Manager::Handle monkeyhead_handle = m.add_mesh(monkey_head);
 
 		// UBO stores mesh transform data (mvp)
-		ssbo->terminal_resize(sizeof(tz::Mat4) * max_elements);
+		ssbo->terminal_resize(sizeof(tz::Mat4) * 3 * max_elements);
 		// Scene uses UBO resource data.
-		tz::render::Scene<tz::render::SceneElement> scene{ssbo->map()};
+		MyScene scene{ssbo->map()};
 
 		float rotation_y = 0.0f;
 
@@ -167,15 +319,24 @@ int main()
             tex_ssbo->send(&metal_handle);
 		}
         // Lighting information
+        constexpr std::size_t light_buf_size = sizeof(tz::Vec3) + sizeof(float) /*extra padding required*/ + (sizeof(PointLight) * max_lights) /*point lights*/;
         tz::Vec3* ambient_lighting;
-        light_ssbo->terminal_resize(sizeof(tz::Vec3));
+        std::array<PointLight*, max_lights> lights;
+        light_ssbo->terminal_resize(light_buf_size);
         {
-            tz::mem::Block blk = light_ssbo->map();
-            ambient_lighting = new (blk.begin) tz::Vec3{};
-            blk.begin = reinterpret_cast<char*>(blk.begin) + sizeof(tz::Vec3);
+		    tz::mem::Block blk = light_ssbo->map();
+			ambient_lighting = new (blk.begin) tz::Vec3{};
+			blk.begin = reinterpret_cast<char*>(blk.begin) + sizeof(tz::Vec3) + /* add extra float because glsl will align to that */sizeof(float);
+            tz::mem::UniformPool<PointLight> light_pool{blk};
+            for(std::size_t i = 0; i < max_lights; i++)
+            {
+                const PointLight default_light{tz::Vec3{}, tz::Vec3{0.5f, 0.0f, 0.0f}, 0.0f};
+                light_pool.set(i, default_light);
+                lights[i] = &light_pool[i];
+            }
         }
 
-        tz::dui::emplace_window<LightingDemoWindow>(ambient_lighting);
+        tz::dui::emplace_window<LightingDemoWindow>(ambient_lighting, lights);
 
 		tz::gl::ShaderCompiler cpl;
 		tz::gl::ShaderProgram prg;
diff --git a/src/core/tz.cpp b/src/core/tz.cpp
index 38b27245..af920f72 100644
--- a/src/core/tz.cpp
+++ b/src/core/tz.cpp
@@ -20,7 +20,6 @@ namespace tz
 		// Initialise GLFW...
 		tz::ext::glfw::initialise(tz::ext::glfw::WindowCreationArgs{app_name, 1920, 1080, visible});
 		// Create the GLFW window and set this to be the global GLFW context window.
-		tz::ext::glad::get().pre_init();
 		this->tz_window = std::make_unique<GLFWWindow>(tz::ext::glfw::get());
 		this->tz_window->set_active_context();
 		tz::ext::glad::get().load();
diff --git a/src/core/tz_glad/glad_context.cpp b/src/core/tz_glad/glad_context.cpp
index 7b267a86..e301535b 100644
--- a/src/core/tz_glad/glad_context.cpp
+++ b/src/core/tz_glad/glad_context.cpp
@@ -19,18 +19,6 @@ namespace tz::ext::glad
 	}
 	
 	GLADContext::GLADContext() noexcept: glfw_context(nullptr), loaded(false), supported_extensions(){}
-
-	void GLADContext::pre_init()
-	{
-		// Core context
-		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
-		#if TOPAZ_DEBUG
-			glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);
-		#else
-			// No Errors
-			glfwWindowHint(GLFW_CONTEXT_NO_ERROR, GLFW_TRUE);
-		#endif
-	}
 	
 	void GLADContext::load()
 	{
@@ -85,31 +73,12 @@ namespace tz::ext::glad
 
 	void GLADContext::populate_extensions()
 	{
-		const GLubyte* extensions_list = glGetString(GL_EXTENSIONS);
-		std::vector<std::string> extension_names;
-		{
-			// Make copy of extensions_list.
-			const GLubyte* offset_byte = extensions_list;
-			topaz_assert(offset_byte != nullptr, "glGetString(GL_EXTENSIONS) returned nullptr");
-			std::string cur;
-			// Separated by spaces, but we obviously end on a null-terminator.
-			while(*offset_byte != '\0')
-			{
-				if(*offset_byte != ' ')
-				{
-					cur += static_cast<char>(*(offset_byte));
-				}
-				else
-				{
-					extension_names.push_back(cur);
-					cur.clear();
-				}
-				offset_byte++;
-			}
-		}
-		for(std::string& str : extension_names)
+		GLint num_extensions;
+		glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);
+		this->supported_extensions.reserve(num_extensions);
+		for(GLuint i = 0; i < static_cast<GLuint>(num_extensions); i++)
 		{
-			this->supported_extensions.push_back({std::move(str)});
+			this->supported_extensions.push_back(OpenGLExtension{std::string{reinterpret_cast<const char*>(glGetStringi(GL_EXTENSIONS, i))}});
 		}
 	}
 	
diff --git a/src/core/tz_glad/glad_context.hpp b/src/core/tz_glad/glad_context.hpp
index 3997f7e5..b049f4f8 100644
--- a/src/core/tz_glad/glad_context.hpp
+++ b/src/core/tz_glad/glad_context.hpp
@@ -35,7 +35,6 @@ namespace tz::ext::glad
 		 * It is not recommended that you construct GLAD contexts manually -- tz should handle this for you.
 		 */
 		GLADContext() noexcept;
-		void pre_init();
 		/**
 		 * Instruct GLAD to load all necessary OpenGL procedures.
 		 * The GLFW context provided at construction must be initialised, or this function will assert.
diff --git a/src/core/tz_glfw/glfw_window.cpp b/src/core/tz_glfw/glfw_window.cpp
index 0df865be..8048ef5c 100644
--- a/src/core/tz_glfw/glfw_window.cpp
+++ b/src/core/tz_glfw/glfw_window.cpp
@@ -25,8 +25,23 @@ namespace tz::ext::glfw
 			window_handle(nullptr), title(title), frame(nullptr)
 	{
 		glfwWindowHint(GLFW_VISIBLE, initially_visible ? GLFW_TRUE : GLFW_FALSE);
+		// Core context 4.6
+		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
+		#if TOPAZ_DEBUG
+			glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);
+		#else
+			// No Errors
+			glfwWindowHint(GLFW_CONTEXT_NO_ERROR, GLFW_TRUE);
+		#endif
+		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
+		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
 		this->window_handle = glfwCreateWindow(width, height, title, monitor, share);
-		topaz_assert(this->window_handle != nullptr, "GLFWWindowImpl::GLFWWindowImpl(...): Failed to initialise glfw window!");
+		if(this->window_handle == nullptr)
+		{
+			const char* err_msg;
+			int code = glfwGetError(&err_msg);
+			topaz_assert(false, "GLFWWindowImpl::GLFWWindowImpl(...): Failed to initialise glfw window! Code: ", code, ", error: ", err_msg);
+		}
 		this->frame = std::make_unique<tz::gl::WindowFrame>(this->window_handle);
 		glfwSetKeyCallback(this->window_handle, glfw_key_callback);
 		glfwSetCharCallback(this->window_handle, glfw_char_callback);
diff --git a/src/geo/matrix.hpp b/src/geo/matrix.hpp
index d04c42f9..b8982980 100644
--- a/src/geo/matrix.hpp
+++ b/src/geo/matrix.hpp
@@ -71,7 +71,7 @@ namespace tz
 		#endif
 	private:
 		// 16-byte alignment to make it as easy as possible to auto-vectorise.
-		alignas(16) std::array<Row, C> mat;
+		std::array<Row, C> mat;
 	};
 
 	using Mat4 = Matrix<float, 4, 4>;
diff --git a/src/geo/matrix.inl b/src/geo/matrix.inl
index 1a4a4be7..990042f2 100644
--- a/src/geo/matrix.inl
+++ b/src/geo/matrix.inl
@@ -362,12 +362,24 @@ namespace tz
 	Matrix<T, R, C> Matrix<T, R, C>::transpose() const
 	{
 		Matrix<T, R, C> m = *this;
+		for(std::size_t i = 0; i < R; i++)
+		{
+			for(std::size_t j = 0; j < C; j++)
+			{
+				if(i != j)
+				{
+					std::swap(m(i, j), m(j, i));
+				}
+			}
+		}
+		/*
 		std::swap(m(0, 1), m(1, 0));
 		std::swap(m(0, 2), m(2, 0));
 		std::swap(m(1, 2), m(2, 1));
 		std::swap(m(0, 3), m(3, 0));
 		std::swap(m(1, 3), m(3, 1));
 		std::swap(m(2, 3), m(3, 2));
+		*/
 		return m;
 	}
 
diff --git a/src/memory/align.hpp b/src/memory/align.hpp
index a843f489..49f58b94 100644
--- a/src/memory/align.hpp
+++ b/src/memory/align.hpp
@@ -13,7 +13,7 @@ namespace tz::mem
 	 * @{
 	 */
 	
-	template<typename T, std::size_t Align>
+	template<typename T, std::size_t Align = std::alignment_of_v<T>>
 	bool is_aligned(const T& t);
 
 	/**
diff --git a/src/memory/pool.inl b/src/memory/pool.inl
index 9d592864..6ae3fb2a 100644
--- a/src/memory/pool.inl
+++ b/src/memory/pool.inl
@@ -2,6 +2,7 @@
 #include <cstddef>
 #include <tuple>
 #include <memory>
+#include "memory/align.hpp"
 
 namespace tz::mem
 {	
@@ -63,6 +64,7 @@ namespace tz::mem
 		}
 		// Now create our object here. No need to do anything with the return result because we are laundering memory.
 		new (ptr) T{t};
+		topaz_assert(tz::mem::is_aligned(*ptr), "UniformPool<T>::set(", index, ", T): Unaligned construction of T detected.");
 		// Make sure our mask is long enough.
 		this->object_mask.resize(std::max(index + 1, this->object_mask.capacity()), false);
 		// And obviously we now have an object here.
