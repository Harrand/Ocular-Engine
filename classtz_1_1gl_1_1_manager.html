<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: tz::gl::Manager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Topaz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tz</b></li><li class="navelem"><b>gl</b></li><li class="navelem"><a class="el" href="classtz_1_1gl_1_1_manager.html">Manager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtz_1_1gl_1_1_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tz::gl::Manager Class Reference<div class="ingroups"><a class="el" href="group__tz__gl.html">Topaz Graphics Library (tz::gl)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Managed <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a> which implicitly has data buffers prepared.  
 <a href="classtz_1_1gl_1_1_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="manager_8hpp_source.html">manager.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1c8905f633fdda78c7b8b1ec4e47102e"><td class="memItemLeft" align="right" valign="top"><a id="a1c8905f633fdda78c7b8b1ec4e47102e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Handle</b> = std::size_t</td></tr>
<tr class="separator:a1c8905f633fdda78c7b8b1ec4e47102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acde294664341f8588f2349766628d024"><td class="memItemLeft" align="right" valign="top"><a id="acde294664341f8588f2349766628d024"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#acde294664341f8588f2349766628d024">Manager</a> ()</td></tr>
<tr class="memdesc:acde294664341f8588f2349766628d024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>. <br /></td></tr>
<tr class="separator:acde294664341f8588f2349766628d024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b0aa3ee058117a4850655618d0181e"><td class="memItemLeft" align="right" valign="top">Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#a20b0aa3ee058117a4850655618d0181e">add_mesh</a> (<a class="el" href="structtz_1_1gl_1_1_indexed_mesh.html">tz::gl::IndexedMesh</a> data)</td></tr>
<tr class="memdesc:a20b0aa3ee058117a4850655618d0181e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the data of an indexed mesh into the <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>'s internal buffers and retrieve a handle which can be used to ascertain the location of the data.  <a href="classtz_1_1gl_1_1_manager.html#a20b0aa3ee058117a4850655618d0181e">More...</a><br /></td></tr>
<tr class="separator:a20b0aa3ee058117a4850655618d0181e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e61d8ef0cfdfb45cb202f11882896c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#a60e61d8ef0cfdfb45cb202f11882896c">get_vertices_offset</a> (Handle handle) const</td></tr>
<tr class="memdesc:a60e61d8ef0cfdfb45cb202f11882896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of vertices preceding the first vertex corresponding to the indexed mesh data associated with the given handle.  <a href="classtz_1_1gl_1_1_manager.html#a60e61d8ef0cfdfb45cb202f11882896c">More...</a><br /></td></tr>
<tr class="separator:a60e61d8ef0cfdfb45cb202f11882896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed695c06c90b5c9390a4cadf2f0931f"><td class="memItemLeft" align="right" valign="top"><a id="aeed695c06c90b5c9390a4cadf2f0931f"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_indices_offset</b> (Handle handle) const</td></tr>
<tr class="separator:aeed695c06c90b5c9390a4cadf2f0931f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adade202f0df592c536d151d1a1fcdbc0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#adade202f0df592c536d151d1a1fcdbc0">get_number_of_vertices</a> (Handle handle) const</td></tr>
<tr class="memdesc:adade202f0df592c536d151d1a1fcdbc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of vertices corresponding to the indexed mesh data associated with the given handle.  <a href="classtz_1_1gl_1_1_manager.html#adade202f0df592c536d151d1a1fcdbc0">More...</a><br /></td></tr>
<tr class="separator:adade202f0df592c536d151d1a1fcdbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412d265cc595ad38f2d35f9872758bdf"><td class="memItemLeft" align="right" valign="top"><a id="a412d265cc595ad38f2d35f9872758bdf"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_number_of_indices</b> (Handle handle) const</td></tr>
<tr class="separator:a412d265cc595ad38f2d35f9872758bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe821d3c9c9e6266de12a1e8e78e8ea"><td class="memItemLeft" align="right" valign="top">Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#a6fe821d3c9c9e6266de12a1e8e78e8ea">partition</a> (Handle handle, std::size_t vertex_offset)</td></tr>
<tr class="memdesc:a6fe821d3c9c9e6266de12a1e8e78e8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relinquish a handle's ownership of some or all of its internal mesh data.  <a href="classtz_1_1gl_1_1_manager.html#a6fe821d3c9c9e6266de12a1e8e78e8ea">More...</a><br /></td></tr>
<tr class="separator:a6fe821d3c9c9e6266de12a1e8e78e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024855890b09be688e09674db5561979"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Handle &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#a024855890b09be688e09674db5561979">split</a> (Handle handle, std::size_t stride_vertices)</td></tr>
<tr class="memdesc:a024855890b09be688e09674db5561979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the internal mesh data corresponding to a given handle into a set of daughter handles.  <a href="classtz_1_1gl_1_1_manager.html#a024855890b09be688e09674db5561979">More...</a><br /></td></tr>
<tr class="separator:a024855890b09be688e09674db5561979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad685e7ec8055296bb49fe79b814d50dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtz_1_1gl_1_1_object.html">tz::gl::Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#ad685e7ec8055296bb49fe79b814d50dc">operator*</a> ()</td></tr>
<tr class="memdesc:ad685e7ec8055296bb49fe79b814d50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the underlying <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a>.  <a href="classtz_1_1gl_1_1_manager.html#ad685e7ec8055296bb49fe79b814d50dc">More...</a><br /></td></tr>
<tr class="separator:ad685e7ec8055296bb49fe79b814d50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa536d86da3c3ea58287dd9f649347a8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtz_1_1gl_1_1_object.html">tz::gl::Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#aaa536d86da3c3ea58287dd9f649347a8">operator*</a> () const</td></tr>
<tr class="memdesc:aaa536d86da3c3ea58287dd9f649347a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the underlying <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a>.  <a href="classtz_1_1gl_1_1_manager.html#aaa536d86da3c3ea58287dd9f649347a8">More...</a><br /></td></tr>
<tr class="separator:aaa536d86da3c3ea58287dd9f649347a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5a297f564da3895058f9c407486f91"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_manager.html#a4e5a297f564da3895058f9c407486f91">get_indices</a> () const</td></tr>
<tr class="memdesc:a4e5a297f564da3895058f9c407486f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a handle corresponding to the internal index-buffer handle used by this <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>.  <a href="classtz_1_1gl_1_1_manager.html#a4e5a297f564da3895058f9c407486f91">More...</a><br /></td></tr>
<tr class="separator:a4e5a297f564da3895058f9c407486f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Managed <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a> which implicitly has data buffers prepared. </p>
<p>This should be used in-place of a <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a> if no special data format is required and normal meshes are to be used. Managers don't create any terminal buffers by default. If you want them, it is recommended to retrieve the manager's object and create them yourself. The manager will never attempt to use any buffers that it hasn't created itself. Contains:</p><ul>
<li>Data <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a></li>
<li>Indices <a class="el" href="classtz_1_1gl_1_1_buffer.html">Buffer</a> </li>
</ul>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a20b0aa3ee058117a4850655618d0181e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b0aa3ee058117a4850655618d0181e">&#9670;&nbsp;</a></span>add_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manager::Handle tz::gl::Manager::add_mesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtz_1_1gl_1_1_indexed_mesh.html">tz::gl::IndexedMesh</a>&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the data of an indexed mesh into the <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>'s internal buffers and retrieve a handle which can be used to ascertain the location of the data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Indexed mesh data to copy into the internal buffers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Opaque handle corresponding to the copied mesh data. </dd></dl>

</div>
</div>
<a id="a4e5a297f564da3895058f9c407486f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5a297f564da3895058f9c407486f91">&#9670;&nbsp;</a></span>get_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tz::gl::Manager::get_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a handle corresponding to the internal index-buffer handle used by this <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>. </p>
<p>Note: This is a very unsafe API method. This is exposed only for potential optimisations and ease-of-use in demos. It is recommended not to use this API method as it is likely to become deprecated in the future. </p>

</div>
</div>
<a id="adade202f0df592c536d151d1a1fcdbc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adade202f0df592c536d151d1a1fcdbc0">&#9670;&nbsp;</a></span>get_number_of_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tz::gl::Manager::get_number_of_vertices </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of vertices corresponding to the indexed mesh data associated with the given handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle whose mesh data size should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of vertices comprising the mesh data. </dd></dl>

</div>
</div>
<a id="a60e61d8ef0cfdfb45cb202f11882896c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e61d8ef0cfdfb45cb202f11882896c">&#9670;&nbsp;</a></span>get_vertices_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tz::gl::Manager::get_vertices_offset </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of vertices preceding the first vertex corresponding to the indexed mesh data associated with the given handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle whose mesh data offset should be retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of vertices between the beginning of the internal buffer's data, and the beginning of the handle's mesh data. </dd></dl>

</div>
</div>
<a id="ad685e7ec8055296bb49fe79b814d50dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad685e7ec8055296bb49fe79b814d50dc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtz_1_1gl_1_1_object.html">tz::gl::Object</a> &amp; tz::gl::Manager::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the underlying <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a>. </p>
<p>There are few functional restrictions to using the object this way. This is a very unsafe API method. This is exposed only for potential optimisations and ease-of-use in demos. It is recommended not to use this API method as it is likely to become deprecated in the future. There are some recommendations:</p>
<ul>
<li>While it is not an error to read-from or write-to any of the existing buffers, know that these buffers are used by this <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>.<ul>
<li>Resizing these buffers however, will invoke UB without asserting.</li>
<li>It is also okay to map these buffers. However, they must be unmapped prior to the next invocation of this-&gt;<a class="el" href="classtz_1_1gl_1_1_manager.html#a20b0aa3ee058117a4850655618d0181e" title="Copy the data of an indexed mesh into the Manager&#39;s internal buffers and retrieve a handle which can ...">add_mesh()</a>. Otherwise, this will invoke UB without asserting.</li>
</ul>
</li>
<li>It is well-defined to make these existing buffers terminal. However, you must not use this-&gt;<a class="el" href="classtz_1_1gl_1_1_manager.html#a20b0aa3ee058117a4850655618d0181e" title="Copy the data of an indexed mesh into the Manager&#39;s internal buffers and retrieve a handle which can ...">add_mesh()</a> to add any additional mesh data. If you do this when the buffers are terminal, this will invoke UB without asserting.</li>
<li>Erasing any existing buffers of this <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">Object</a> which you did not create yourself will invoke UB without asserting. </li>
</ul>

</div>
</div>
<a id="aaa536d86da3c3ea58287dd9f649347a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa536d86da3c3ea58287dd9f649347a8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtz_1_1gl_1_1_object.html">tz::gl::Object</a> &amp; tz::gl::Manager::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the underlying <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">tz::gl::Object</a>. </p>
<p>There are few functional restrictions to using the object this way. This is a very unsafe API method. This is exposed only for potential optimisations and ease-of-use in demos. It is recommended not to use this API method as it is likely to become deprecated in the future. There are some recommendations:</p>
<ul>
<li>While it is not an error to read-from or write-to any of the existing buffers, know that these buffers are used by this <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>.<ul>
<li>Resizing these buffers however, will invoke UB without asserting.</li>
<li>It is also okay to map these buffers. However, they must be unmapped prior to the next invocation of this-&gt;<a class="el" href="classtz_1_1gl_1_1_manager.html#a20b0aa3ee058117a4850655618d0181e" title="Copy the data of an indexed mesh into the Manager&#39;s internal buffers and retrieve a handle which can ...">add_mesh()</a>. Otherwise, this will invoke UB without asserting.</li>
</ul>
</li>
<li>It is well-defined to make these existing buffers terminal. However, you must not use this-&gt;<a class="el" href="classtz_1_1gl_1_1_manager.html#a20b0aa3ee058117a4850655618d0181e" title="Copy the data of an indexed mesh into the Manager&#39;s internal buffers and retrieve a handle which can ...">add_mesh()</a> to add any additional mesh data. If you do this when the buffers are terminal, this will invoke UB without asserting.</li>
<li>Erasing any existing buffers of this <a class="el" href="classtz_1_1gl_1_1_object.html" title="tz::gl::Objects represent arbitrary Objects stored in VRAM.">Object</a> which you did not create yourself will invoke UB without asserting. </li>
</ul>

</div>
</div>
<a id="a6fe821d3c9c9e6266de12a1e8e78e8ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe821d3c9c9e6266de12a1e8e78e8ea">&#9670;&nbsp;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Manager::Handle tz::gl::Manager::partition </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>vertex_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relinquish a handle's ownership of some or all of its internal mesh data. </p>
<p>Precondition: The given handle has previously been created by this <a class="el" href="classtz_1_1gl_1_1_manager.html" title="Managed tz::gl::Object which implicitly has data buffers prepared.">Manager</a>. Otherwise, this will assert and invoke UB. Precondition: The vertex offset provided is smaller than the number of vertices occupied by the handle. Otherwise, this will assert and invoke UB. Example Scenario: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] |-------------------------&mdash;| Handle 0 manager-&gt;partition(0, 3); New data arrangement: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] |---&mdash;| |--------------&mdash;| Handle 0 Handle X (Returns X)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Handle corresponding to the initial mesh data. </td></tr>
    <tr><td class="paramname">vertex_offset</td><td>Desired number of vertices corresponding to the given handle. The remainder of these vertices will be owned by the new handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle corresponding to the remainder of the vertices taken away from the initial Handle. </dd></dl>

</div>
</div>
<a id="a024855890b09be688e09674db5561979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024855890b09be688e09674db5561979">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename Manager::Handle &gt; tz::gl::Manager::split </td>
          <td>(</td>
          <td class="paramtype">Handle&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>stride_vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the internal mesh data corresponding to a given handle into a set of daughter handles. </p>
<p>Each daughter handle is expected to own the same amount of vertices. This is useful to split a large mesh into multiple sub-meshes. Note: This is not tessellation or mesh-cutting &ndash; No mesh data is actually manipulated at all. Note: The daughter handles will also contain the initial handle. This is guaranteed to be its first element. Precondition: Number of vertices occupied by the given handle is divisible by the stride. This is necessary to ensure that all daughters have the same vertex quantity. If not, this will assert and invoke UB. Precondition: Stride must be greater than 0. Otherwise, this will invoke UB without asserting.</p>
<p>Example Scenario: [0, 1, 2, 3, 4, 5] |-------------&mdash;| Handle 0 manager-&gt;split(0, 2); New data arrangement: [0, 1, 2, 3, 4, 5] |&ndash;| |&ndash;| |&ndash;| h0 hX hY (Returns {0, X, Y}) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/gl/<a class="el" href="manager_8hpp_source.html">manager.hpp</a></li>
<li>src/gl/manager.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
