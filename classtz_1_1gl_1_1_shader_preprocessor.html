<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: tz::gl::ShaderPreprocessor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Topaz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tz</b></li><li class="navelem"><b>gl</b></li><li class="navelem"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html">ShaderPreprocessor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtz_1_1gl_1_1_shader_preprocessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tz::gl::ShaderPreprocessor Class Reference<div class="ingroups"><a class="el" href="group__tz__gl.html">Topaz Graphics Library (tz::gl)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html" title="ShaderPreprocessor is the basis of TZGLP.">ShaderPreprocessor</a> is the basis of TZGLP.  
 <a href="classtz_1_1gl_1_1_shader_preprocessor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="shader__preprocessor_8hpp_source.html">shader_preprocessor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a297279262113e6183b4e4f4edaa4e36c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a297279262113e6183b4e4f4edaa4e36c">ShaderPreprocessor</a> (std::string source=&quot;&quot;)</td></tr>
<tr class="memdesc:a297279262113e6183b4e4f4edaa4e36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html" title="ShaderPreprocessor is the basis of TZGLP.">ShaderPreprocessor</a> with a source code fragment to apply transformations to.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#a297279262113e6183b4e4f4edaa4e36c">More...</a><br /></td></tr>
<tr class="separator:a297279262113e6183b4e4f4edaa4e36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97379ec78a4fa3eeb9583ed323577029"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a97379ec78a4fa3eeb9583ed323577029">size</a> () const</td></tr>
<tr class="memdesc:a97379ec78a4fa3eeb9583ed323577029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of active modules.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#a97379ec78a4fa3eeb9583ed323577029">More...</a><br /></td></tr>
<tr class="separator:a97379ec78a4fa3eeb9583ed323577029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55f85aa03ae988bc98cbe1f7a1340f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#ab55f85aa03ae988bc98cbe1f7a1340f5">empty</a> () const</td></tr>
<tr class="memdesc:ab55f85aa03ae988bc98cbe1f7a1340f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether there are any modules in this preprocessor.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#ab55f85aa03ae988bc98cbe1f7a1340f5">More...</a><br /></td></tr>
<tr class="separator:ab55f85aa03ae988bc98cbe1f7a1340f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c1d01d0e4a3eb9f6e0ad163857a925"><td class="memTemplParams" colspan="2">template&lt;typename ModuleT , typename... Args&gt; </td></tr>
<tr class="memitem:ac3c1d01d0e4a3eb9f6e0ad163857a925"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#ac3c1d01d0e4a3eb9f6e0ad163857a925">emplace_module</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac3c1d01d0e4a3eb9f6e0ad163857a925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Module in-place.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#ac3c1d01d0e4a3eb9f6e0ad163857a925">More...</a><br /></td></tr>
<tr class="separator:ac3c1d01d0e4a3eb9f6e0ad163857a925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66fba71f95a28f7b167eea3aa06bf94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#aa66fba71f95a28f7b167eea3aa06bf94">swap_modules</a> (std::size_t a, std::size_t b)</td></tr>
<tr class="memdesc:aa66fba71f95a28f7b167eea3aa06bf94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the indices of two existing Modules in the preprocessor.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#aa66fba71f95a28f7b167eea3aa06bf94">More...</a><br /></td></tr>
<tr class="separator:aa66fba71f95a28f7b167eea3aa06bf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2320684ba7d5cb611d1b25eb74e883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#aed2320684ba7d5cb611d1b25eb74e883">preprocess</a> ()</td></tr>
<tr class="memdesc:aed2320684ba7d5cb611d1b25eb74e883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke all Modules on the source-fragment.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#aed2320684ba7d5cb611d1b25eb74e883">More...</a><br /></td></tr>
<tr class="separator:aed2320684ba7d5cb611d1b25eb74e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791b635a2c47e5eb2b9a4a9797d4a7f6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a791b635a2c47e5eb2b9a4a9797d4a7f6">result</a> () const</td></tr>
<tr class="memdesc:a791b635a2c47e5eb2b9a4a9797d4a7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the transformed source-fragment.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#a791b635a2c47e5eb2b9a4a9797d4a7f6">More...</a><br /></td></tr>
<tr class="separator:a791b635a2c47e5eb2b9a4a9797d4a7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee16bc817c854fa4e8aa251f9dd9c1"><td class="memItemLeft" align="right" valign="top"><a id="a6aee16bc817c854fa4e8aa251f9dd9c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a6aee16bc817c854fa4e8aa251f9dd9c1">set_source</a> (std::string source)</td></tr>
<tr class="memdesc:a6aee16bc817c854fa4e8aa251f9dd9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document. <br /></td></tr>
<tr class="separator:a6aee16bc817c854fa4e8aa251f9dd9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78401f29115fd7c131c99f65cb81b285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtz_1_1gl_1_1p_1_1_i_module.html">p::IModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a78401f29115fd7c131c99f65cb81b285">operator[]</a> (std::size_t idx)</td></tr>
<tr class="memdesc:a78401f29115fd7c131c99f65cb81b285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to an existing Module based upon its index.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#a78401f29115fd7c131c99f65cb81b285">More...</a><br /></td></tr>
<tr class="separator:a78401f29115fd7c131c99f65cb81b285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9db6e2e8d231597984a28e01c79950"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classtz_1_1gl_1_1p_1_1_i_module.html">p::IModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#aee9db6e2e8d231597984a28e01c79950">operator[]</a> (std::size_t idx) const</td></tr>
<tr class="memdesc:aee9db6e2e8d231597984a28e01c79950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to an existing Module based upon its index.  <a href="classtz_1_1gl_1_1_shader_preprocessor.html#aee9db6e2e8d231597984a28e01c79950">More...</a><br /></td></tr>
<tr class="separator:aee9db6e2e8d231597984a28e01c79950"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html" title="ShaderPreprocessor is the basis of TZGLP.">ShaderPreprocessor</a> is the basis of TZGLP. </p>
<p>ShaderPreprocessors are executed on <a class="el" href="classtz_1_1gl_1_1_shader.html" title="Shader components which are attached to ShaderPrograms.">Shader</a> component source-code prior to upload and compilation.</p>
<p>The idea is to populate a ShaderPreprocessors with Modules offering features that you want, and running it on the source before passing it to the graphics drivers for compilation. This allows us to have extremely useful interactivity between the Topaz engine runtime and the shaders that you have written.</p>
<p>Example: SSBOs are supported natively in GLSL. However, SSBO binding code is required on the C++ side to read/write to the SSBO and set it up properly... Using a <a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html" title="ShaderPreprocessor is the basis of TZGLP.">ShaderPreprocessor</a>, one could use a bespoke module to instead declare SSBOs in GLSL via a preprocessor directive. This allows the TZ runtime to automatically execute some binding-code, preventing you from having to write it!</p>
<p>See <a class="el" href="classtz_1_1gl_1_1p_1_1_i_module.html" title="Interface for a ShaderPreprocessor Module.">tz::gl::p::IModule</a> and subclasses for features offered by modules. You're also encouraged to write your own! It's trivial to write a custom Module and emplace it into your <a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html" title="ShaderPreprocessor is the basis of TZGLP.">ShaderPreprocessor</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a297279262113e6183b4e4f4edaa4e36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297279262113e6183b4e4f4edaa4e36c">&#9670;&nbsp;</a></span>ShaderPreprocessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tz::gl::ShaderPreprocessor::ShaderPreprocessor </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>source</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html" title="ShaderPreprocessor is the basis of TZGLP.">ShaderPreprocessor</a> with a source code fragment to apply transformations to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source-code to transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac3c1d01d0e4a3eb9f6e0ad163857a925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c1d01d0e4a3eb9f6e0ad163857a925">&#9670;&nbsp;</a></span>emplace_module()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModuleT , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tz::gl::ShaderPreprocessor::emplace_module </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a Module in-place. </p>
<p>It will be the last module to run during preprocessing.</p>
<p>Note: To change the order of module execution, emplace the Module here and invoke swap_module using the resultant index with another index. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ModuleT</td><td>Module Type to construct. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments used to construct the ModuleT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Values of arguments used to construct the ModuleT. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resultant index of the created ModuleT. </dd></dl>

</div>
</div>
<a id="ab55f85aa03ae988bc98cbe1f7a1340f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55f85aa03ae988bc98cbe1f7a1340f5">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tz::gl::ShaderPreprocessor::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether there are any modules in this preprocessor. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there are any modules. Otherwise false. </dd></dl>

</div>
</div>
<a id="a78401f29115fd7c131c99f65cb81b285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78401f29115fd7c131c99f65cb81b285">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtz_1_1gl_1_1p_1_1_i_module.html">p::IModule</a> * tz::gl::ShaderPreprocessor::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to an existing Module based upon its index. </p>
<p>Precondition: idx &lt; this-&gt;<a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a97379ec78a4fa3eeb9583ed323577029" title="Retrieve the number of active modules.">size()</a>. Otherwise, this will assert and invoke UB. </p>

</div>
</div>
<a id="aee9db6e2e8d231597984a28e01c79950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9db6e2e8d231597984a28e01c79950">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classtz_1_1gl_1_1p_1_1_i_module.html">p::IModule</a> * tz::gl::ShaderPreprocessor::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to an existing Module based upon its index. </p>
<p>Precondition: idx &lt; this-&gt;<a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a97379ec78a4fa3eeb9583ed323577029" title="Retrieve the number of active modules.">size()</a>. Otherwise, this will assert and invoke UB. </p>

</div>
</div>
<a id="aed2320684ba7d5cb611d1b25eb74e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2320684ba7d5cb611d1b25eb74e883">&#9670;&nbsp;</a></span>preprocess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::ShaderPreprocessor::preprocess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke all Modules on the source-fragment. </p>
<p>Note: This will update the internal source-fragment. Invoking preprocess will simulate a second preprocessor pass. This may or may not be desirable. Note: The transformed source-fragment will become available in this-&gt;<a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a791b635a2c47e5eb2b9a4a9797d4a7f6" title="Retrieve the transformed source-fragment.">result()</a>. </p>

</div>
</div>
<a id="a791b635a2c47e5eb2b9a4a9797d4a7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791b635a2c47e5eb2b9a4a9797d4a7f6">&#9670;&nbsp;</a></span>result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; tz::gl::ShaderPreprocessor::result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the transformed source-fragment. </p>
<p>Note: It is not an error to invoke this before preprocess. In which case this will simply return the source unchanged. </p><dl class="section return"><dt>Returns</dt><dd>The initial source-fragment, post any transformations applied by preprocessing invocations. </dd></dl>

</div>
</div>
<a id="a97379ec78a4fa3eeb9583ed323577029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97379ec78a4fa3eeb9583ed323577029">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t tz::gl::ShaderPreprocessor::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of active modules. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of modules used in this preprocessor. </dd></dl>

</div>
</div>
<a id="aa66fba71f95a28f7b167eea3aa06bf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66fba71f95a28f7b167eea3aa06bf94">&#9670;&nbsp;</a></span>swap_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tz::gl::ShaderPreprocessor::swap_modules </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the indices of two existing Modules in the preprocessor. </p>
<p>Note: Modules are invoked in ascending order of index. Use this to swap the order of execution of Modules as you wish. Precondition: a &lt; this-size() &amp;&amp; b &lt; this-&gt;<a class="el" href="classtz_1_1gl_1_1_shader_preprocessor.html#a97379ec78a4fa3eeb9583ed323577029" title="Retrieve the number of active modules.">size()</a>. Otherwise this will assert and invoke UB. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/gl/<a class="el" href="shader__preprocessor_8hpp_source.html">shader_preprocessor.hpp</a></li>
<li>src/gl/shader_preprocessor.cpp</li>
<li>src/gl/shader_preprocessor.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
