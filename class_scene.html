<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: Scene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Topaz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_scene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="scene_8hpp_source.html">scene.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa8796c250db3ade796b749e2819a7c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#aa8796c250db3ade796b749e2819a7c89">Scene</a> (ScenePartitionType type=ScenePartitionType::OCTREE)</td></tr>
<tr class="separator:aa8796c250db3ade796b749e2819a7c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e6354478dc7df82446b3abf9f91d96"><td class="memItemLeft" align="right" valign="top"><a id="aa6e6354478dc7df82446b3abf9f91d96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (const <a class="el" href="class_scene.html">Scene</a> &amp;copy)</td></tr>
<tr class="separator:aa6e6354478dc7df82446b3abf9f91d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ffa90c8bd138db46b3b177f7df6709"><td class="memItemLeft" align="right" valign="top"><a id="a90ffa90c8bd138db46b3b177f7df6709"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b> (<a class="el" href="class_scene.html">Scene</a> &amp;&amp;move)</td></tr>
<tr class="separator:a90ffa90c8bd138db46b3b177f7df6709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2847e25ee0d5149ee4fc5f28b19b14d0"><td class="memItemLeft" align="right" valign="top"><a id="a2847e25ee0d5149ee4fc5f28b19b14d0"></a>
<a class="el" href="class_scene.html">Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_scene.html">Scene</a> rhs)</td></tr>
<tr class="separator:a2847e25ee0d5149ee4fc5f28b19b14d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b9caab68b50b03b8c0ad5736fa84ce"><td class="memItemLeft" align="right" valign="top"><a id="a29b9caab68b50b03b8c0ad5736fa84ce"></a>
<a class="el" href="class_scene.html">Scene</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_scene.html">Scene</a> &amp;&amp;rhs)</td></tr>
<tr class="separator:a29b9caab68b50b03b8c0ad5736fa84ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a33c0c72143904134fb295a5556fbd8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a3a33c0c72143904134fb295a5556fbd8">render</a> (<a class="el" href="class_render_pass.html">RenderPass</a> render_pass) const</td></tr>
<tr class="separator:a3a33c0c72143904134fb295a5556fbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5280bc60b1bd8a5a40090c7c9cfa4353"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a5280bc60b1bd8a5a40090c7c9cfa4353">update</a> (float delta_time)</td></tr>
<tr class="separator:a5280bc60b1bd8a5a40090c7c9cfa4353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa908a38c94044d0e94f891392a3373ca"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#aa908a38c94044d0e94f891392a3373ca">get_number_of_static_objects</a> () const</td></tr>
<tr class="separator:aa908a38c94044d0e94f891392a3373ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420eb1facbfa07e2b2b581f9b6e4a47a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a420eb1facbfa07e2b2b581f9b6e4a47a">get_number_of_sprites</a> () const</td></tr>
<tr class="separator:a420eb1facbfa07e2b2b581f9b6e4a47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a83efd55f6f4418c88599b00237c28"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#ac2a83efd55f6f4418c88599b00237c28">get_number_of_elements</a> () const</td></tr>
<tr class="separator:ac2a83efd55f6f4418c88599b00237c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285d5cc3034900e0ba3385974258b30c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="class_static_object.html">StaticObject</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a285d5cc3034900e0ba3385974258b30c">get_static_objects</a> () const</td></tr>
<tr class="separator:a285d5cc3034900e0ba3385974258b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf2303541f0a6485869432bfdc433ab"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="class_sprite.html">Sprite</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a2bf2303541f0a6485869432bfdc433ab">get_sprites</a> () const</td></tr>
<tr class="separator:a2bf2303541f0a6485869432bfdc433ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f863a9209d35c6e4558a3a03047fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_a_b_b.html">AABB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a69f863a9209d35c6e4558a3a03047fd9">get_boundary</a> (std::optional&lt; std::pair&lt; const <a class="el" href="class_camera.html">Camera</a> &amp;, <a class="el" href="class_vector2.html">Vector2I</a> &gt;&gt; frustum_culling=std::nullopt) const</td></tr>
<tr class="separator:a69f863a9209d35c6e4558a3a03047fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49d36bd44583a0374eedf41ccce75d3"><td class="memTemplParams" colspan="2">template&lt;class Element , typename... Args&gt; </td></tr>
<tr class="memitem:ab49d36bd44583a0374eedf41ccce75d3"><td class="memTemplItemLeft" align="right" valign="top">Element &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_scene.html#ab49d36bd44583a0374eedf41ccce75d3">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab49d36bd44583a0374eedf41ccce75d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b855e1bc8d9516f3e5b49d27b72dad"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a46b855e1bc8d9516f3e5b49d27b72dad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_static_object.html">StaticObject</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_scene.html#a46b855e1bc8d9516f3e5b49d27b72dad">emplace_object</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a46b855e1bc8d9516f3e5b49d27b72dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739042af94d55c0ce38a3a3f4dea5f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a739042af94d55c0ce38a3a3f4dea5f66">remove_object</a> (<a class="el" href="class_static_object.html">StaticObject</a> &amp;object)</td></tr>
<tr class="separator:a739042af94d55c0ce38a3a3f4dea5f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c17e3b91949f2fdb7487b8c3457868"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae9c17e3b91949f2fdb7487b8c3457868"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_sprite.html">Sprite</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_scene.html#ae9c17e3b91949f2fdb7487b8c3457868">emplace_sprite</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:ae9c17e3b91949f2fdb7487b8c3457868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4b2987723d8a73734af1c90c0a08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a4af4b2987723d8a73734af1c90c0a08b">remove_sprite</a> (<a class="el" href="class_sprite.html">Sprite</a> &amp;sprite)</td></tr>
<tr class="separator:a4af4b2987723d8a73734af1c90c0a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3cd5cdcb4877a34fb50332ac6ca105c"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_directional_light.html">DirectionalLight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#ad3cd5cdcb4877a34fb50332ac6ca105c">get_directional_light</a> (std::size_t light_id) const</td></tr>
<tr class="separator:ad3cd5cdcb4877a34fb50332ac6ca105c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0b78d640e4b70b52d7254c2e5c1ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a5f0b78d640e4b70b52d7254c2e5c1ac2">set_directional_light</a> (std::size_t light_id, <a class="el" href="class_directional_light.html">DirectionalLight</a> light)</td></tr>
<tr class="separator:a5f0b78d640e4b70b52d7254c2e5c1ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb13c4e6c6014cb7768d9af3aa8bc87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#accb13c4e6c6014cb7768d9af3aa8bc87">add_directional_light</a> (<a class="el" href="class_directional_light.html">DirectionalLight</a> light)</td></tr>
<tr class="separator:accb13c4e6c6014cb7768d9af3aa8bc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f04ba3ce70f10918e753ef42af8494"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="class_point_light.html">PointLight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#ab4f04ba3ce70f10918e753ef42af8494">get_point_light</a> (std::size_t light_id) const</td></tr>
<tr class="separator:ab4f04ba3ce70f10918e753ef42af8494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedb7574259b28bfcbc68cba00bfc043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#afedb7574259b28bfcbc68cba00bfc043">set_point_light</a> (std::size_t light_id, <a class="el" href="class_point_light.html">PointLight</a> light)</td></tr>
<tr class="separator:afedb7574259b28bfcbc68cba00bfc043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08de7ebe00fd213f9f993eb5cc159a3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a08de7ebe00fd213f9f993eb5cc159a3e">add_point_light</a> (<a class="el" href="class_point_light.html">PointLight</a> light)</td></tr>
<tr class="separator:a08de7ebe00fd213f9f993eb5cc159a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0b682168526e36b5619a2704ef7a1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a0b0b682168526e36b5619a2704ef7a1d">contains_octree</a> () const</td></tr>
<tr class="separator:a0b0b682168526e36b5619a2704ef7a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6acd75af01fe4c377075a4d286a78b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_scene_partition_node.html">ScenePartitionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a3f6acd75af01fe4c377075a4d286a78b">get_octree_root</a> () const</td></tr>
<tr class="separator:a3f6acd75af01fe4c377075a4d286a78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099e4dd53a93a3bde37848af0f948df8"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; const <a class="el" href="class_renderable.html">Renderable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a099e4dd53a93a3bde37848af0f948df8">raycast</a> (<a class="el" href="class_vector2.html">Vector2I</a> screen_position, <a class="el" href="class_render_pass.html">RenderPass</a> render_pass) const</td></tr>
<tr class="separator:a099e4dd53a93a3bde37848af0f948df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3fcc72eb2678562882d4f437dc28c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_renderable.html">Renderable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#afe3fcc72eb2678562882d4f437dc28c8">get_renderable_by_id</a> (std::size_t index) const</td></tr>
<tr class="separator:afe3fcc72eb2678562882d4f437dc28c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b8b48db08d123511b0edf77b9bee71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_renderable.html">Renderable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a24b8b48db08d123511b0edf77b9bee71">get_renderable_by_id</a> (std::size_t index)</td></tr>
<tr class="separator:a24b8b48db08d123511b0edf77b9bee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0592639dbcc9e5d3d2112390f92bb872"><td class="memTemplParams" colspan="2">template&lt;class RenderableType &gt; </td></tr>
<tr class="memitem:a0592639dbcc9e5d3d2112390f92bb872"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_scene_section.html">SceneSection</a>&lt; RenderableType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_scene.html#a0592639dbcc9e5d3d2112390f92bb872">get_renderables_by_type</a> ()</td></tr>
<tr class="separator:a0592639dbcc9e5d3d2112390f92bb872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409256a34be9ddccfe96c2de210e090e"><td class="memTemplParams" colspan="2">template&lt;class RenderableType &gt; </td></tr>
<tr class="memitem:a409256a34be9ddccfe96c2de210e090e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_scene_section.html">SceneSection</a>&lt; const RenderableType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_scene.html#a409256a34be9ddccfe96c2de210e090e">get_renderables_by_type</a> () const</td></tr>
<tr class="separator:a409256a34be9ddccfe96c2de210e090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5284780c5b1eec6a5e652577051f9f"><td class="memTemplParams" colspan="2">template&lt;class RenderableType  = Renderable&gt; </td></tr>
<tr class="memitem:a8b5284780c5b1eec6a5e652577051f9f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_scene.html#a8b5284780c5b1eec6a5e652577051f9f">get_number_of</a> () const</td></tr>
<tr class="separator:a8b5284780c5b1eec6a5e652577051f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d5c5ea151752b6755aaadc8b117321"><td class="memItemLeft" align="right" valign="top"><a id="ab7d5c5ea151752b6755aaadc8b117321"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab7d5c5ea151752b6755aaadc8b117321"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_number_of</b> () const</td></tr>
<tr class="separator:ab7d5c5ea151752b6755aaadc8b117321"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a56c6dcdf56f18b095da8f961203bdc32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a56c6dcdf56f18b095da8f961203bdc32">erase_object</a> (<a class="el" href="class_renderable.html">Renderable</a> *to_delete)</td></tr>
<tr class="separator:a56c6dcdf56f18b095da8f961203bdc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c56a08adf9f9f58dce8910adf6aa467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a7c56a08adf9f9f58dce8910adf6aa467">handle_deletions</a> ()</td></tr>
<tr class="separator:a7c56a08adf9f9f58dce8910adf6aa467"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:afdf07853ddfa3a7b184bc1a6ab969185"><td class="memItemLeft" align="right" valign="top"><a id="afdf07853ddfa3a7b184bc1a6ab969185"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="class_scene.html">Scene</a> &amp;lhs, <a class="el" href="class_scene.html">Scene</a> &amp;rhs)</td></tr>
<tr class="separator:afdf07853ddfa3a7b184bc1a6ab969185"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a488f332a2c363953636146854286ddec"><td class="memItemLeft" align="right" valign="top"><a id="a488f332a2c363953636146854286ddec"></a>
<a class="el" href="class_renderable_buffer.html">RenderableBuffer</a>&lt; <a class="el" href="class_static_object.html">StaticObject</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>object_buffer</b></td></tr>
<tr class="separator:a488f332a2c363953636146854286ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cee433012101e89d31255442a729999"><td class="memItemLeft" align="right" valign="top"><a id="a4cee433012101e89d31255442a729999"></a>
std::vector&lt; <a class="el" href="class_renderable.html">Renderable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#a4cee433012101e89d31255442a729999">objects</a></td></tr>
<tr class="memdesc:a4cee433012101e89d31255442a729999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all objects in the scene which can be rendered. <br /></td></tr>
<tr class="separator:a4cee433012101e89d31255442a729999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fb63663a08d33f9bdd291c471e8724"><td class="memItemLeft" align="right" valign="top"><a id="af9fb63663a08d33f9bdd291c471e8724"></a>
std::unordered_multimap&lt; std::type_index, <a class="el" href="class_renderable.html">Renderable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#af9fb63663a08d33f9bdd291c471e8724">inheritance_map</a></td></tr>
<tr class="memdesc:af9fb63663a08d33f9bdd291c471e8724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores Renderable* referring to all possible sub-types of <a class="el" href="class_renderable.html">Renderable</a>. E.g all StaticObjects will be in the same range, without having to do it in O(n) time checking through every renderable in the scene. <br /></td></tr>
<tr class="separator:af9fb63663a08d33f9bdd291c471e8724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e8aba6af4f2fda8a81ba4dd6dba502"><td class="memItemLeft" align="right" valign="top"><a id="aa2e8aba6af4f2fda8a81ba4dd6dba502"></a>
std::vector&lt; <a class="el" href="class_directional_light.html">DirectionalLight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#aa2e8aba6af4f2fda8a81ba4dd6dba502">directional_lights</a></td></tr>
<tr class="memdesc:aa2e8aba6af4f2fda8a81ba4dd6dba502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all DirectionalLights in the <a class="el" href="class_scene.html">Scene</a>. <br /></td></tr>
<tr class="separator:aa2e8aba6af4f2fda8a81ba4dd6dba502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a5ee1bd4e77f1f0746abd5c96760a1"><td class="memItemLeft" align="right" valign="top"><a id="af1a5ee1bd4e77f1f0746abd5c96760a1"></a>
std::vector&lt; <a class="el" href="class_point_light.html">PointLight</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#af1a5ee1bd4e77f1f0746abd5c96760a1">point_lights</a></td></tr>
<tr class="memdesc:af1a5ee1bd4e77f1f0746abd5c96760a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all PointLights in the <a class="el" href="class_scene.html">Scene</a>. <br /></td></tr>
<tr class="separator:af1a5ee1bd4e77f1f0746abd5c96760a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafac9e0264b412d950b57aa23b7760f9"><td class="memItemLeft" align="right" valign="top"><a id="aafac9e0264b412d950b57aa23b7760f9"></a>
std::vector&lt; <a class="el" href="class_renderable.html">Renderable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#aafac9e0264b412d950b57aa23b7760f9">objects_to_delete</a></td></tr>
<tr class="memdesc:aafac9e0264b412d950b57aa23b7760f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all objects that have been requested for deletion in the next <a class="el" href="class_scene.html#a5280bc60b1bd8a5a40090c7c9cfa4353">Scene::update()</a> invocation. <br /></td></tr>
<tr class="separator:aafac9e0264b412d950b57aa23b7760f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c81093becb2347d36dcc4891e1e314"><td class="memItemLeft" align="right" valign="top"><a id="ac9c81093becb2347d36dcc4891e1e314"></a>
std::optional&lt; <a class="el" href="class_scene_partition_node.html">ScenePartitionNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_scene.html#ac9c81093becb2347d36dcc4891e1e314">octree</a></td></tr>
<tr class="memdesc:ac9c81093becb2347d36dcc4891e1e314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Octree for nodes. <br /></td></tr>
<tr class="separator:ac9c81093becb2347d36dcc4891e1e314"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a50491849faa10a141625b9a7e5794358"><td class="memTemplParams" colspan="2"><a id="a50491849faa10a141625b9a7e5794358"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50491849faa10a141625b9a7e5794358"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SceneSection</b></td></tr>
<tr class="separator:a50491849faa10a141625b9a7e5794358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Container of all renderable objects in a given scene. Provides support for StaticObjects and DynamicObjects (3D) and Sprites and DynamicSprites (2D). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa8796c250db3ade796b749e2819a7c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8796c250db3ade796b749e2819a7c89">&#9670;&nbsp;</a></span>Scene()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scene::Scene </td>
          <td>(</td>
          <td class="paramtype">ScenePartitionType&#160;</td>
          <td class="paramname"><em>type</em> = <code>ScenePartitionType::OCTREE</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialise an empty scene. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="accb13c4e6c6014cb7768d9af3aa8bc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb13c4e6c6014cb7768d9af3aa8bc87">&#9670;&nbsp;</a></span>add_directional_light()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::add_directional_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_directional_light.html">DirectionalLight</a>&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a given <a class="el" href="class_directional_light.html">DirectionalLight</a> to the <a class="el" href="class_scene.html">Scene</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>- The <a class="el" href="class_directional_light.html">DirectionalLight</a> to add to the <a class="el" href="class_scene.html">Scene</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08de7ebe00fd213f9f993eb5cc159a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08de7ebe00fd213f9f993eb5cc159a3e">&#9670;&nbsp;</a></span>add_point_light()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::add_point_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_point_light.html">PointLight</a>&#160;</td>
          <td class="paramname"><em>light</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a given <a class="el" href="class_point_light.html">PointLight</a> to the <a class="el" href="class_scene.html">Scene</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light</td><td>- The <a class="el" href="class_point_light.html">PointLight</a> to add to the <a class="el" href="class_scene.html">Scene</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b0b682168526e36b5619a2704ef7a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0b682168526e36b5619a2704ef7a1d">&#9670;&nbsp;</a></span>contains_octree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Scene::contains_octree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query as to whether this scene uses an octree for its space partitioning. </p><dl class="section return"><dt>Returns</dt><dd>- True if an octree is used. Otherwise false </dd></dl>

</div>
</div>
<a id="ab49d36bd44583a0374eedf41ccce75d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49d36bd44583a0374eedf41ccce75d3">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Element &amp; Scene::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given any element type, construct such an element in-place into this <a class="el" href="class_scene.html">Scene</a>. Note: This will always invoke a heap-allocation. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Element</td><td>- Type of element to emplace, including <a class="el" href="class_static_object.html">StaticObject</a>, <a class="el" href="class_dynamic_object.html">DynamicObject</a>, <a class="el" href="class_sprite.html">Sprite</a>, <a class="el" href="class_dynamic_sprite.html">DynamicSprite</a> and all subclasses of these classes </td></tr>
    <tr><td class="paramname">Args</td><td>- Argument types used to construct the given element </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>- Argument values used to construct the given element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- A reference to the constructed element </dd></dl>

</div>
</div>
<a id="a46b855e1bc8d9516f3e5b49d27b72dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b855e1bc8d9516f3e5b49d27b72dad">&#9670;&nbsp;</a></span>emplace_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_static_object.html">StaticObject</a> &amp; Scene::emplace_object </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="class_static_object.html">StaticObject</a> in-place into this <a class="el" href="class_scene.html">Scene</a>. Note: This will always invoke a heap-allocation. Note: This is equivalent to 'Scene::emplace&lt;StaticObject&gt;(args...)'. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>- Argument types used to construct the given <a class="el" href="class_static_object.html">StaticObject</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>- Argument values used to construct the given <a class="el" href="class_static_object.html">StaticObject</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- A reference to the constructed <a class="el" href="class_static_object.html">StaticObject</a> </dd></dl>

</div>
</div>
<a id="ae9c17e3b91949f2fdb7487b8c3457868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c17e3b91949f2fdb7487b8c3457868">&#9670;&nbsp;</a></span>emplace_sprite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sprite.html">Sprite</a> &amp; Scene::emplace_sprite </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="class_sprite.html">Sprite</a> in-place into this <a class="el" href="class_scene.html">Scene</a>. Note: This will always invoke a heap-allocation. Note: This is equivalent to 'Scene::emplace&lt;Sprite&gt;(args...)'. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>- Argument types used to construct the given <a class="el" href="class_sprite.html">Sprite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>- Argument values used to construct the given <a class="el" href="class_sprite.html">Sprite</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- A reference to the constructed <a class="el" href="class_sprite.html">Sprite</a> </dd></dl>

</div>
</div>
<a id="a56c6dcdf56f18b095da8f961203bdc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c6dcdf56f18b095da8f961203bdc32">&#9670;&nbsp;</a></span>erase_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::erase_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_renderable.html">Renderable</a> *&#160;</td>
          <td class="paramname"><em>to_delete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protected. Erase the given <a class="el" href="class_renderable.html">Renderable</a> from the <a class="el" href="class_scene.html">Scene</a> instantly. Note: This retains the difference in behaviour mentioned in Scene::remove_object(Renderable&amp;). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_delete</td><td>- The <a class="el" href="class_renderable.html">Renderable</a> to erase from the <a class="el" href="class_scene.html">Scene</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69f863a9209d35c6e4558a3a03047fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f863a9209d35c6e4558a3a03047fd9">&#9670;&nbsp;</a></span>get_boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_a_b_b.html">AABB</a> Scene::get_boundary </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; std::pair&lt; const <a class="el" href="class_camera.html">Camera</a> &amp;, <a class="el" href="class_vector2.html">Vector2I</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>frustum_culling</em> = <code>std::nullopt</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain an <a class="el" href="class_a_a_b_b.html">AABB</a> engulfing all 3D objects in the <a class="el" href="class_scene.html">Scene</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frustum_culling_camera</td><td>- Optional camera to frustum-cull the scene before bounding it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- <a class="el" href="class_a_a_b_b.html">AABB</a> containing the whole <a class="el" href="class_scene.html">Scene</a> </dd></dl>

</div>
</div>
<a id="ad3cd5cdcb4877a34fb50332ac6ca105c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3cd5cdcb4877a34fb50332ac6ca105c">&#9670;&nbsp;</a></span>get_directional_light()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_directional_light.html">DirectionalLight</a> &gt; Scene::get_directional_light </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>light_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the <a class="el" href="class_directional_light.html">DirectionalLight</a> with the given ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light_id</td><td>- The ID of the <a class="el" href="class_directional_light.html">DirectionalLight</a> to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The <a class="el" href="class_directional_light.html">DirectionalLight</a> corresponding to the given ID. If no <a class="el" href="class_directional_light.html">DirectionalLight</a> exists with the ID, a null-optional is returned </dd></dl>

</div>
</div>
<a id="a8b5284780c5b1eec6a5e652577051f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5284780c5b1eec6a5e652577051f9f">&#9670;&nbsp;</a></span>get_number_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RenderableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Scene::get_number_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the number of renderables in the scene exactly matching the given type. Note: This will not include sub-types of the given type. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RenderableType</td><td>- Type of renderable to retrieve the quantity of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Number of Renderables in the scene whose type exactly matches RenderableType (such as <a class="el" href="class_static_object.html">StaticObject</a>) </dd></dl>

</div>
</div>
<a id="ac2a83efd55f6f4418c88599b00237c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a83efd55f6f4418c88599b00237c28">&#9670;&nbsp;</a></span>get_number_of_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Scene::get_number_of_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of elements in the <a class="el" href="class_scene.html">Scene</a>, including 2D and 3D objects. </p><dl class="section return"><dt>Returns</dt><dd>- Total number of objects and sprites in the <a class="el" href="class_scene.html">Scene</a> </dd></dl>

</div>
</div>
<a id="a420eb1facbfa07e2b2b581f9b6e4a47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420eb1facbfa07e2b2b581f9b6e4a47a">&#9670;&nbsp;</a></span>get_number_of_sprites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Scene::get_number_of_sprites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of 2D sprites in the <a class="el" href="class_scene.html">Scene</a>. This includes Sprites, DynamicSprites, and any utilised subclass of either of these. </p><dl class="section return"><dt>Returns</dt><dd>- The number of 2D sprites in the <a class="el" href="class_scene.html">Scene</a> </dd></dl>

</div>
</div>
<a id="aa908a38c94044d0e94f891392a3373ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa908a38c94044d0e94f891392a3373ca">&#9670;&nbsp;</a></span>get_number_of_static_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Scene::get_number_of_static_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of 3D objects in the <a class="el" href="class_scene.html">Scene</a>. This includes StaticObjects, DynamicObjects and any utilised subclass of either of these. </p><dl class="section return"><dt>Returns</dt><dd>- The number of 3D objects in the <a class="el" href="class_scene.html">Scene</a> </dd></dl>

</div>
</div>
<a id="a3f6acd75af01fe4c377075a4d286a78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6acd75af01fe4c377075a4d286a78b">&#9670;&nbsp;</a></span>get_octree_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_scene_partition_node.html">ScenePartitionNode</a> * Scene::get_octree_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the root node in the octree partitioning the renderables in the scene, if it exists. </p><dl class="section return"><dt>Returns</dt><dd>- Pointer to octree node if it exists. Otherwise nullptr </dd></dl>

</div>
</div>
<a id="ab4f04ba3ce70f10918e753ef42af8494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f04ba3ce70f10918e753ef42af8494">&#9670;&nbsp;</a></span>get_point_light()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="class_point_light.html">PointLight</a> &gt; Scene::get_point_light </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>light_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pointLight with the given ID. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light_id</td><td>- The ID of the <a class="el" href="class_point_light.html">PointLight</a> to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The <a class="el" href="class_point_light.html">PointLight</a> corresponding to the given ID. If no <a class="el" href="class_point_light.html">PointLight</a> exists with the ID, a null-optional is returned </dd></dl>

</div>
</div>
<a id="a24b8b48db08d123511b0edf77b9bee71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b8b48db08d123511b0edf77b9bee71">&#9670;&nbsp;</a></span>get_renderable_by_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_renderable.html">Renderable</a> * Scene::get_renderable_by_id </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an index into the <a class="el" href="class_renderable.html">Renderable</a> vector, return the <a class="el" href="class_renderable.html">Renderable</a> at that index, if one exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- Index of the <a class="el" href="class_renderable.html">Renderable</a> to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Pointer to the desired <a class="el" href="class_renderable.html">Renderable</a> if it exists. Otherwise nullptr </dd></dl>

</div>
</div>
<a id="afe3fcc72eb2678562882d4f437dc28c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3fcc72eb2678562882d4f437dc28c8">&#9670;&nbsp;</a></span>get_renderable_by_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_renderable.html">Renderable</a> * Scene::get_renderable_by_id </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an index into the <a class="el" href="class_renderable.html">Renderable</a> vector, return the <a class="el" href="class_renderable.html">Renderable</a> at that index, if one exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>- Index of the <a class="el" href="class_renderable.html">Renderable</a> to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Pointer to the desired <a class="el" href="class_renderable.html">Renderable</a> if it exists. Otherwise nullptr </dd></dl>

</div>
</div>
<a id="a0592639dbcc9e5d3d2112390f92bb872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0592639dbcc9e5d3d2112390f92bb872">&#9670;&nbsp;</a></span>get_renderables_by_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RenderableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_scene_section.html">SceneSection</a>&lt; RenderableType &gt; Scene::get_renderables_by_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a section of the scene which can be iterated through. The section contains all elements of the scene which are both sub-type of <a class="el" href="class_renderable.html">Renderable</a> and is equal to the given template parameter. Note: This does not include sub-types of the parameter. Note: This has average constant time complexity. Note: If you want a given type and all its sub-types, you must go through all Renderables and use tz::functional::is_a&lt;Renderable, RenderableType&gt;(renderable_ptr) instead, which would have average linear time complexity </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RenderableType</td><td>- Type of the <a class="el" href="class_renderable.html">Renderable</a> sub-type to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Iterable section containing all scene renderables of type RenderableType </dd></dl>

</div>
</div>
<a id="a409256a34be9ddccfe96c2de210e090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409256a34be9ddccfe96c2de210e090e">&#9670;&nbsp;</a></span>get_renderables_by_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RenderableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_scene_section.html">SceneSection</a>&lt; const RenderableType &gt; Scene::get_renderables_by_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a section of the scene which can be iterated through. The section contains all elements of the scene which are both sub-type of <a class="el" href="class_renderable.html">Renderable</a> and is equal to the given template parameter. Note: This does not include sub-types of the parameter. Note: This has average constant time complexity. Note: If you want a given type and all its sub-types, you must go through all Renderables and use tz::functional::is_a&lt;Renderable, RenderableType&gt;(renderable_ptr) instead, which would have average linear time complexity </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RenderableType</td><td>- Type of the <a class="el" href="class_renderable.html">Renderable</a> sub-type to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Iterable section containing all scene renderables of type RenderableType </dd></dl>

</div>
</div>
<a id="a2bf2303541f0a6485869432bfdc433ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf2303541f0a6485869432bfdc433ab">&#9670;&nbsp;</a></span>get_sprites()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="class_sprite.html">Sprite</a> &gt; &gt; Scene::get_sprites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain a container of constant-references to all Sprites, DynamicSprites and any utilised subclasses of either of these in the <a class="el" href="class_scene.html">Scene</a>. </p><dl class="section return"><dt>Returns</dt><dd>- Container of constant-references to all 2D objects in the <a class="el" href="class_scene.html">Scene</a> </dd></dl>

</div>
</div>
<a id="a285d5cc3034900e0ba3385974258b30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285d5cc3034900e0ba3385974258b30c">&#9670;&nbsp;</a></span>get_static_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::reference_wrapper&lt; const <a class="el" href="class_static_object.html">StaticObject</a> &gt; &gt; Scene::get_static_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain a container of constant-references to all StaticObjects, DynamicObjects and any utilised subclasses of either of these in the <a class="el" href="class_scene.html">Scene</a>. </p><dl class="section return"><dt>Returns</dt><dd>- Container of constant-references to all 3D objects in the <a class="el" href="class_scene.html">Scene</a> </dd></dl>

</div>
</div>
<a id="a7c56a08adf9f9f58dce8910adf6aa467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c56a08adf9f9f58dce8910adf6aa467">&#9670;&nbsp;</a></span>handle_deletions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::handle_deletions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protected. Handle all of the queued deletion requests made by <a class="el" href="class_scene.html#a739042af94d55c0ce38a3a3f4dea5f66">Scene::remove_object(StaticObject&amp;)</a> and <a class="el" href="class_scene.html#a4af4b2987723d8a73734af1c90c0a08b">Scene::remove_sprite(Sprite&amp;)</a>. Note: If you are using <a class="el" href="class_scene.html#a56c6dcdf56f18b095da8f961203bdc32">Scene::erase_object(Renderable*)</a> instead, then this method is unneeded. </p>

</div>
</div>
<a id="a099e4dd53a93a3bde37848af0f948df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099e4dd53a93a3bde37848af0f948df8">&#9670;&nbsp;</a></span>raycast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; const <a class="el" href="class_renderable.html">Renderable</a> * &gt; Scene::raycast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector2.html">Vector2I</a>&#160;</td>
          <td class="paramname"><em>screen_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_render_pass.html">RenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simulate a raycast from the given point on the screen. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screen_position</td><td>- Position on the screen to emit a ray from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Set of pointers to collided objects, if any exist. </dd></dl>

</div>
</div>
<a id="a739042af94d55c0ce38a3a3f4dea5f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739042af94d55c0ce38a3a3f4dea5f66">&#9670;&nbsp;</a></span>remove_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::remove_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_static_object.html">StaticObject</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a reference to an existing <a class="el" href="class_static_object.html">StaticObject</a>, erase this object from the <a class="el" href="class_scene.html">Scene</a> in the next <a class="el" href="class_scene.html#a5280bc60b1bd8a5a40090c7c9cfa4353">Scene::update()</a> invocation. Note: This method supports polymorphic StaticObjects, including DynamicObjects. Note: The behaviour of this method will vary depending on whether the object was stack-allocated or heap-allocated:</p><ul>
<li>If stack-allocated, the first object equal to the argument shall be deleted (Shallowly-equated).</li>
<li>If heap-allocated, the object matching the exact memory address to the parameter shall be deleted (Deeply-equated).</li>
<li>If there is no matching object in the <a class="el" href="class_scene.html">Scene</a>, nothing happens. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>- The object to delete from this <a class="el" href="class_scene.html">Scene</a>. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a4af4b2987723d8a73734af1c90c0a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af4b2987723d8a73734af1c90c0a08b">&#9670;&nbsp;</a></span>remove_sprite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::remove_sprite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sprite.html">Sprite</a> &amp;&#160;</td>
          <td class="paramname"><em>sprite</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a reference to an existing <a class="el" href="class_sprite.html">Sprite</a>, erase this object from the <a class="el" href="class_scene.html">Scene</a> in the next <a class="el" href="class_scene.html#a5280bc60b1bd8a5a40090c7c9cfa4353">Scene::update()</a> invocation. Note: This method supports polymorphic Sprites, including DynamicSprites. Note: The behaviour of this method will vary depending on whether the object was stack-allocated or heap-allocated:</p><ul>
<li>If stack-allocated, the first object equal to the argument shall be deleted (Shallowly-equated).</li>
<li>If heap-allocated, the object matching the exact memory address to the parameter shall be deleted (Deeply-equated).</li>
<li>If there is no matching object in the <a class="el" href="class_scene.html">Scene</a>, nothing happens. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sprite</td><td>- The sprite to delete from this <a class="el" href="class_scene.html">Scene</a>. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a3a33c0c72143904134fb295a5556fbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a33c0c72143904134fb295a5556fbd8">&#9670;&nbsp;</a></span>render()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_render_pass.html">RenderPass</a>&#160;</td>
          <td class="paramname"><em>render_pass</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Render the scene into the currently-bound <a class="el" href="class_frame_buffer.html">FrameBuffer</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">render_shader</td><td>- The Shader with which to render all of the 3D objects in this <a class="el" href="class_scene.html">Scene</a> </td></tr>
    <tr><td class="paramname">sprite_shader</td><td>- The Shader with which to render all of the 2D objects in this <a class="el" href="class_scene.html">Scene</a> </td></tr>
    <tr><td class="paramname">camera</td><td>- The <a class="el" href="class_camera.html">Camera</a> whose perspective should be used in rendering the <a class="el" href="class_scene.html">Scene</a> </td></tr>
    <tr><td class="paramname">viewport_dimensions</td><td>- The dimensions (width and height) of the currently-bound <a class="el" href="class_frame_buffer.html">FrameBuffer</a>'s viewport </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f0b78d640e4b70b52d7254c2e5c1ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0b78d640e4b70b52d7254c2e5c1ac2">&#9670;&nbsp;</a></span>set_directional_light()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::set_directional_light </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>light_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_directional_light.html">DirectionalLight</a>&#160;</td>
          <td class="paramname"><em>light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the <a class="el" href="class_directional_light.html">DirectionalLight</a> value with the given ID. Note: If the ID is greater than the number of DirectionalLights, then the underlying container's size will expand to the given ID.</p><ul>
<li>For example, if there are 2 DirectionalLights, and Scene::set_directional_light(1000, some_light), then 997 DirectionalLights shall be default-constructed, and one copy of the given <a class="el" href="class_directional_light.html">DirectionalLight</a> is copied into ID 1000.</li>
<li>If the ID of the <a class="el" href="class_directional_light.html">DirectionalLight</a> is unneeded, it is recommend to use <a class="el" href="class_scene.html#accb13c4e6c6014cb7768d9af3aa8bc87">Scene::add_directional_light(DirectionalLight)</a> instead. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light_id</td><td>- The ID of the <a class="el" href="class_directional_light.html">DirectionalLight</a> to assign </td></tr>
    <tr><td class="paramname">light</td><td>- The <a class="el" href="class_directional_light.html">DirectionalLight</a> value to assign to the given ID </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="afedb7574259b28bfcbc68cba00bfc043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedb7574259b28bfcbc68cba00bfc043">&#9670;&nbsp;</a></span>set_point_light()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::set_point_light </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>light_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_point_light.html">PointLight</a>&#160;</td>
          <td class="paramname"><em>light</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the pointLight value with the given ID. Note: If the ID is greater than the number of PointLights, then the underlying container's size will expand to the given ID.</p><ul>
<li>For example, if there are 2 PointLights, and Scene::set_point_light(1000, some_light), then 997 PointLights shall be default-constructed, and one copy of the given <a class="el" href="class_point_light.html">PointLight</a> is copied into ID 1000.</li>
<li>If the ID of the <a class="el" href="class_point_light.html">PointLight</a> is unneeded, it is recommended to use <a class="el" href="class_scene.html#a08de7ebe00fd213f9f993eb5cc159a3e">Scene::add_point_light(PointLight)</a> instead. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">light_id</td><td>- The ID of the <a class="el" href="class_point_light.html">PointLight</a> to assign </td></tr>
    <tr><td class="paramname">light</td><td>- The <a class="el" href="class_point_light.html">PointLight</a> value to assign to the given ID </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="a5280bc60b1bd8a5a40090c7c9cfa4353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5280bc60b1bd8a5a40090c7c9cfa4353">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Scene::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delta_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invoke all tick-based (Physics) updates for all objects in the <a class="el" href="class_scene.html">Scene</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta_time</td><td>- The time taken, in seconds, since the last update invocation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/core/<a class="el" href="scene_8hpp_source.html">scene.hpp</a></li>
<li>src/core/scene.cpp</li>
<li>src/core/scene.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
