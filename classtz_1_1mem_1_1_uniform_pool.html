<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: tz::mem::UniformPool&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="custom_dark_theme.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Topaz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>tz</b></li><li class="navelem"><b>mem</b></li><li class="navelem"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">UniformPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtz_1_1mem_1_1_uniform_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tz::mem::UniformPool&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__tz__mem.html">Topaz Memory Library (tz::mem)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.  
 <a href="classtz_1_1mem_1_1_uniform_pool.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="pool_8hpp_source.html">pool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a920eca4b56a41a69f84baf623d6f7667"><td class="memItemLeft" align="right" valign="top"><a id="a920eca4b56a41a69f84baf623d6f7667"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a920eca4b56a41a69f84baf623d6f7667"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a608426aabd4c3eae3827e4291586dcb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a608426aabd4c3eae3827e4291586dcb4">UniformPool</a> (void *begin, void *end)</td></tr>
<tr class="memdesc:a608426aabd4c3eae3827e4291586dcb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> between two addresses (inclusive).  <a href="classtz_1_1mem_1_1_uniform_pool.html#a608426aabd4c3eae3827e4291586dcb4">More...</a><br /></td></tr>
<tr class="separator:a608426aabd4c3eae3827e4291586dcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460a3bcbfbcfcc699f23ebf28a579a7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a460a3bcbfbcfcc699f23ebf28a579a7b">UniformPool</a> (<a class="el" href="structtz_1_1mem_1_1_block.html">Block</a> block)</td></tr>
<tr class="memdesc:a460a3bcbfbcfcc699f23ebf28a579a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> to manage an existing memory block.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a460a3bcbfbcfcc699f23ebf28a579a7b">More...</a><br /></td></tr>
<tr class="separator:a460a3bcbfbcfcc699f23ebf28a579a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c843416067dd996ed8e744047e602a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a96c843416067dd996ed8e744047e602a">UniformPool</a> (void *begin, std::size_t size_bytes)</td></tr>
<tr class="memdesc:a96c843416067dd996ed8e744047e602a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> from a beginning address value and a given number of bytes.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a96c843416067dd996ed8e744047e602a">More...</a><br /></td></tr>
<tr class="separator:a96c843416067dd996ed8e744047e602a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5ef76ec650ad517a8c74095007ced2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a5d5ef76ec650ad517a8c74095007ced2">size</a> () const</td></tr>
<tr class="memdesc:a5d5ef76ec650ad517a8c74095007ced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of confirmed-constructed objects within the pool.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a5d5ef76ec650ad517a8c74095007ced2">More...</a><br /></td></tr>
<tr class="separator:a5d5ef76ec650ad517a8c74095007ced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710f7ad6a597082b3db78b097d680906"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906">capacity</a> () const</td></tr>
<tr class="memdesc:a710f7ad6a597082b3db78b097d680906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the maximum number of elements which this pool can store.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906">More...</a><br /></td></tr>
<tr class="separator:a710f7ad6a597082b3db78b097d680906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51762133413823e9356a10f4d91b8382"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a51762133413823e9356a10f4d91b8382">full</a> () const</td></tr>
<tr class="memdesc:a51762133413823e9356a10f4d91b8382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether the pool is filled as much as possible with confirmed-constructed objects.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a51762133413823e9356a10f4d91b8382">More...</a><br /></td></tr>
<tr class="separator:a51762133413823e9356a10f4d91b8382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8555956b27ac6d1fe05349c73c3d95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a5c8555956b27ac6d1fe05349c73c3d95">empty</a> () const</td></tr>
<tr class="memdesc:a5c8555956b27ac6d1fe05349c73c3d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query as to whether the pool contains any confirmed-constructed objects.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a5c8555956b27ac6d1fe05349c73c3d95">More...</a><br /></td></tr>
<tr class="separator:a5c8555956b27ac6d1fe05349c73c3d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99c6da3fccf37bfe2a22cc4ee50f23a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#ae99c6da3fccf37bfe2a22cc4ee50f23a">capacity_bytes</a> () const</td></tr>
<tr class="memdesc:ae99c6da3fccf37bfe2a22cc4ee50f23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the capacity of the underlying memory block.  <a href="classtz_1_1mem_1_1_uniform_pool.html#ae99c6da3fccf37bfe2a22cc4ee50f23a">More...</a><br /></td></tr>
<tr class="separator:ae99c6da3fccf37bfe2a22cc4ee50f23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0366805c248aa0aa8ee53dbcccd3990e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a0366805c248aa0aa8ee53dbcccd3990e">set</a> (std::size_t index, T t)</td></tr>
<tr class="memdesc:a0366805c248aa0aa8ee53dbcccd3990e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a T into the given index within the pool.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a0366805c248aa0aa8ee53dbcccd3990e">More...</a><br /></td></tr>
<tr class="separator:a0366805c248aa0aa8ee53dbcccd3990e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7de7be354e9027d8d79dccca49baec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a5b7de7be354e9027d8d79dccca49baec">set</a> (std::size_t index, std::nullptr_t)</td></tr>
<tr class="memdesc:a5b7de7be354e9027d8d79dccca49baec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an existing T from the pool at the given index.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a5b7de7be354e9027d8d79dccca49baec">More...</a><br /></td></tr>
<tr class="separator:a5b7de7be354e9027d8d79dccca49baec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c25315561139b6ce8caeb9e3d0daca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#ac4c25315561139b6ce8caeb9e3d0daca">erase</a> (std::size_t index)</td></tr>
<tr class="memdesc:ac4c25315561139b6ce8caeb9e3d0daca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an existing T from the pool at the given index.  <a href="classtz_1_1mem_1_1_uniform_pool.html#ac4c25315561139b6ce8caeb9e3d0daca">More...</a><br /></td></tr>
<tr class="separator:ac4c25315561139b6ce8caeb9e3d0daca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9daea001f90730410d4f291fa5d242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a0e9daea001f90730410d4f291fa5d242">clear</a> ()</td></tr>
<tr class="memdesc:a0e9daea001f90730410d4f291fa5d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke <code>erase</code> on all elements of the pool.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a0e9daea001f90730410d4f291fa5d242">More...</a><br /></td></tr>
<tr class="separator:a0e9daea001f90730410d4f291fa5d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8b8c33120ee05f77a390b7c4fc5911"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8c8b8c33120ee05f77a390b7c4fc5911"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a8c8b8c33120ee05f77a390b7c4fc5911">emplace</a> (std::size_t index, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a8c8b8c33120ee05f77a390b7c4fc5911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new T into the given index directly within the pool.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a8c8b8c33120ee05f77a390b7c4fc5911">More...</a><br /></td></tr>
<tr class="separator:a8c8b8c33120ee05f77a390b7c4fc5911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dbb72e8638caa0ee9a06d6056c9aa1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#af6dbb72e8638caa0ee9a06d6056c9aa1">operator[]</a> (std::size_t index) const</td></tr>
<tr class="memdesc:af6dbb72e8638caa0ee9a06d6056c9aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the T at the given index.  <a href="classtz_1_1mem_1_1_uniform_pool.html#af6dbb72e8638caa0ee9a06d6056c9aa1">More...</a><br /></td></tr>
<tr class="separator:af6dbb72e8638caa0ee9a06d6056c9aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aa2570f58ffa053a7c6f8c5895cc0a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a87aa2570f58ffa053a7c6f8c5895cc0a">operator[]</a> (std::size_t index)</td></tr>
<tr class="memdesc:a87aa2570f58ffa053a7c6f8c5895cc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the T at the given index.  <a href="classtz_1_1mem_1_1_uniform_pool.html#a87aa2570f58ffa053a7c6f8c5895cc0a">More...</a><br /></td></tr>
<tr class="separator:a87aa2570f58ffa053a7c6f8c5895cc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b08982363bcce4371cbe9fc18c4561"><td class="memTemplParams" colspan="2">template&lt;typename As  = T&gt; </td></tr>
<tr class="memitem:ac7b08982363bcce4371cbe9fc18c4561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#ac7b08982363bcce4371cbe9fc18c4561">debug_print_as</a> () const</td></tr>
<tr class="memdesc:ac7b08982363bcce4371cbe9fc18c4561"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document.  <a href="classtz_1_1mem_1_1_uniform_pool.html#ac7b08982363bcce4371cbe9fc18c4561">More...</a><br /></td></tr>
<tr class="separator:ac7b08982363bcce4371cbe9fc18c4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca14da1a4b4b5610840f65933a2ef6a"><td class="memItemLeft" align="right" valign="top"><a id="afca14da1a4b4b5610840f65933a2ef6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>operator tz::mem::Block</b> () const</td></tr>
<tr class="separator:afca14da1a4b4b5610840f65933a2ef6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class tz::mem::UniformPool&lt; T &gt;</h3>

<p>Manages a pre-allocated block of memory, treating it as a contiguous array of Ts. </p>
<p>Useful for managing a memory block representing a persistently-mapped buffer (PMB). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of object to store </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a608426aabd4c3eae3827e4291586dcb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608426aabd4c3eae3827e4291586dcb4">&#9670;&nbsp;</a></span>UniformPool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::<a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">UniformPool</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> between two addresses (inclusive). </p>
<p>Precondition: <code>begin</code> and <code>end</code> address values both lie within a single range of application-owned memory. If not, or the addresses belong to different allocations, then this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Begin address. </td></tr>
    <tr><td class="paramname">end</td><td>End address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a460a3bcbfbcfcc699f23ebf28a579a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460a3bcbfbcfcc699f23ebf28a579a7b">&#9670;&nbsp;</a></span>UniformPool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::<a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">UniformPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtz_1_1mem_1_1_block.html">Block</a>&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> to manage an existing memory block. </p>
<p>Precondition: The given memory block is valid. Otherwise, this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>Memory block to manage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96c843416067dd996ed8e744047e602a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c843416067dd996ed8e744047e602a">&#9670;&nbsp;</a></span>UniformPool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::<a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">UniformPool</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> from a beginning address value and a given number of bytes. </p>
<p>The begin address should locate a block of available memory large enough for the pool size. Precondition: <code>begin</code> and <code>reinterpret_cast&lt;char*&gt;(begin) + size_bytes</code> values lie within a single range of application-owned memory. If not, or the addresses belong to different allocations, then this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Begin address. </td></tr>
    <tr><td class="paramname">size_bytes</td><td>Number of additional bytes after the begin address comprising the pool size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a710f7ad6a597082b3db78b097d680906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710f7ad6a597082b3db78b097d680906">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::capacity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the maximum number of elements which this pool can store. </p>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of possible elements. </dd></dl>

</div>
</div>
<a id="ae99c6da3fccf37bfe2a22cc4ee50f23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99c6da3fccf37bfe2a22cc4ee50f23a">&#9670;&nbsp;</a></span>capacity_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::capacity_bytes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the capacity of the underlying memory block. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the pool's underlying memory block, in bytes. </dd></dl>

</div>
</div>
<a id="a0e9daea001f90730410d4f291fa5d242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9daea001f90730410d4f291fa5d242">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke <code>erase</code> on all elements of the pool. </p>
<p>All confirmed-constructed objects will be removed. </p>

</div>
</div>
<a id="ac7b08982363bcce4371cbe9fc18c4561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b08982363bcce4371cbe9fc18c4561">&#9670;&nbsp;</a></span>debug_print_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename As &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::debug_print_as</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TODO: Document. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">As</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c8b8c33120ee05f77a390b7c4fc5911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8b8c33120ee05f77a390b7c4fc5911">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new T into the given index directly within the pool. </p>
<p>Note: If the <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> is considered a T[], then the index represents an index into this array. Precondition: <code>index &lt; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906" title="Retrieve the maximum number of elements which this pool can store.">capacity()</a></code>. Otherwise, this will assert and invoke UB. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Argument type parameters used to construct the T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Desired index where the object should be constructed. </td></tr>
    <tr><td class="paramname">args</td><td>Argument type values used to construct the T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the constructed T. This reference remains valid until the underlying memory pool is freed, or the memory at the index is manipulated externally, or another object is constructed at this index. </dd></dl>

</div>
</div>
<a id="a5c8555956b27ac6d1fe05349c73c3d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8555956b27ac6d1fe05349c73c3d95">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::empty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether the pool contains any confirmed-constructed objects. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the pool contains <em>zero</em> confirmed-constructed objects. False otherwise. </dd></dl>

</div>
</div>
<a id="ac4c25315561139b6ce8caeb9e3d0daca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c25315561139b6ce8caeb9e3d0daca">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an existing T from the pool at the given index. </p>
<p>If no confirmed-constructed T exists at the given index, nothing happens. Precondition: <code>index &lt; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906" title="Retrieve the maximum number of elements which this pool can store.">capacity()</a></code>. Otherwise, this will assert and early-out. Note: This is identical to <code>set(index, nullptr)</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the pool to clear any objects out of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51762133413823e9356a10f4d91b8382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51762133413823e9356a10f4d91b8382">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::full</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query as to whether the pool is filled as much as possible with confirmed-constructed objects. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the pool is full of confirmed-constructed objects. False otherwise. </dd></dl>

</div>
</div>
<a id="a87aa2570f58ffa053a7c6f8c5895cc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aa2570f58ffa053a7c6f8c5895cc0a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the T at the given index. </p>
<p>Note: The T at the given index is required to be valid, but not confirmed-constructed (This is likely to become more strict soon). Precondition: <code>index &lt; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906" title="Retrieve the maximum number of elements which this pool can store.">capacity()</a></code>. Otherwise, this will assert and invoke UB. Precondition: A valid T object exists at the given index. Otherwise, this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Desired index where the object is located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the existing T at the given index. </dd></dl>

</div>
</div>
<a id="af6dbb72e8638caa0ee9a06d6056c9aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6dbb72e8638caa0ee9a06d6056c9aa1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the T at the given index. </p>
<p>Note: The T at the given index is required to be valid, but not confirmed-constructed (This is likely to become more strict soon). Precondition: <code>index &lt; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906" title="Retrieve the maximum number of elements which this pool can store.">capacity()</a></code>. Otherwise, this will assert and invoke UB. Precondition: A valid T object exists at the given index. Otherwise, this will invoke UB without asserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Desired index where the object is located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the existing T at the given index. </dd></dl>

</div>
</div>
<a id="a5b7de7be354e9027d8d79dccca49baec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7de7be354e9027d8d79dccca49baec">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an existing T from the pool at the given index. </p>
<p>If no confirmed-constructed T exists at the given index, nothing happens. Precondition: <code>index &lt; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906" title="Retrieve the maximum number of elements which this pool can store.">capacity()</a></code>. Otherwise, this will assert and early-out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the pool to clear any objects out of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0366805c248aa0aa8ee53dbcccd3990e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0366805c248aa0aa8ee53dbcccd3990e">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a T into the given index within the pool. </p>
<p>Note: If the <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html" title="Manages a pre-allocated block of memory, treating it as a contiguous array of Ts.">UniformPool</a> is considered a T[], then the index represents an index into this array. Precondition: <code>index &lt; <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html#a710f7ad6a597082b3db78b097d680906" title="Retrieve the maximum number of elements which this pool can store.">capacity()</a></code>. Otherwise, this will assert and invoke UB. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Desired index where the object should be constructed. </td></tr>
    <tr><td class="paramname">t</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d5ef76ec650ad517a8c74095007ced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5ef76ec650ad517a8c74095007ced2">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classtz_1_1mem_1_1_uniform_pool.html">tz::mem::UniformPool</a>&lt; T &gt;::size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of confirmed-constructed objects within the pool. </p>
<p>Note: Confirmed-constructed objects are objects which were constructed within the underlying memory block via the pool, and not some external source. </p><dl class="section return"><dt>Returns</dt><dd>Number of confirmed-constructed objects within the pool. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/memory/<a class="el" href="pool_8hpp_source.html">pool.hpp</a></li>
<li>src/memory/pool.inl</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
