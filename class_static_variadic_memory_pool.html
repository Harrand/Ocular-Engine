<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Topaz: StaticVariadicMemoryPool&lt; Ts &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Topaz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_static_variadic_memory_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StaticVariadicMemoryPool&lt; Ts &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="memory_8hpp_source.html">memory.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for StaticVariadicMemoryPool&lt; Ts &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_static_variadic_memory_pool.png" usemap="#StaticVariadicMemoryPool_3C_20Ts_20_3E_map" alt=""/>
  <map id="StaticVariadicMemoryPool_3C_20Ts_20_3E_map" name="StaticVariadicMemoryPool_3C_20Ts_20_3E_map">
<area href="class_memory_pool.html" alt="MemoryPool&lt; char &gt;" shape="rect" coords="0,56,199,80"/>
<area href="class_pool_marker.html" alt="PoolMarker&lt; PoolMarking &gt;" shape="rect" coords="0,0,199,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7158f1c726779d78d3ed50cb05f0704e"><td class="memItemLeft" align="right" valign="top"><a id="a7158f1c726779d78d3ed50cb05f0704e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TupleType</b> = std::tuple&lt; Ts... &gt;</td></tr>
<tr class="separator:a7158f1c726779d78d3ed50cb05f0704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9bbaf21d16cdced110707a0fb6a41f2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#a9bbaf21d16cdced110707a0fb6a41f2e">StaticVariadicMemoryPool</a> (void *begin_address)</td></tr>
<tr class="separator:a9bbaf21d16cdced110707a0fb6a41f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b66977eae1b5bc6b6889f4c64e5820"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#ad0b66977eae1b5bc6b6889f4c64e5820">StaticVariadicMemoryPool</a> (void *begin_address, Ts &amp;&amp;... ts)</td></tr>
<tr class="separator:ad0b66977eae1b5bc6b6889f4c64e5820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac010baab2637d50167fa5214144f7e42"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#ac010baab2637d50167fa5214144f7e42">StaticVariadicMemoryPool</a> (<a class="el" href="class_memory_pool.html">MemoryPool</a>&lt; char &gt; &amp;&amp;fixed_pool)</td></tr>
<tr class="separator:ac010baab2637d50167fa5214144f7e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6859bc07dbe1955f410b351838f76679"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#a6859bc07dbe1955f410b351838f76679">get_element_capacity</a> () const override</td></tr>
<tr class="separator:a6859bc07dbe1955f410b351838f76679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9aa94210059568bdeef86a62b4da88"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#acc9aa94210059568bdeef86a62b4da88">get_byte_capacity</a> () const override</td></tr>
<tr class="separator:acc9aa94210059568bdeef86a62b4da88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2ea1c545181881655a5a458b4d06f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a2ea1c545181881655a5a458b4d06f3"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#a6a2ea1c545181881655a5a458b4d06f3">get</a> ()</td></tr>
<tr class="separator:a6a2ea1c545181881655a5a458b4d06f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3dffd4a8e3cdbeba182da764aab34c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b3dffd4a8e3cdbeba182da764aab34c"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#a6b3dffd4a8e3cdbeba182da764aab34c">get</a> () const</td></tr>
<tr class="separator:a6b3dffd4a8e3cdbeba182da764aab34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f9e983bf8e848639cc1ff930931f7"><td class="memTemplParams" colspan="2">template&lt;std::size_t I&gt; </td></tr>
<tr class="memitem:ac25f9e983bf8e848639cc1ff930931f7"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#ac25f9e983bf8e848639cc1ff930931f7">get</a> ()</td></tr>
<tr class="separator:ac25f9e983bf8e848639cc1ff930931f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d648156035bdbabba39a07f52c453c"><td class="memTemplParams" colspan="2">template&lt;std::size_t I&gt; </td></tr>
<tr class="memitem:a43d648156035bdbabba39a07f52c453c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#a43d648156035bdbabba39a07f52c453c">get</a> () const</td></tr>
<tr class="separator:a43d648156035bdbabba39a07f52c453c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab894571bf1bf451c29bf7e126464ced"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_static_variadic_memory_pool.html#aab894571bf1bf451c29bf7e126464ced">default_all</a> () override</td></tr>
<tr class="separator:aab894571bf1bf451c29bf7e126464ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_memory_pool"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_memory_pool')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_memory_pool.html">MemoryPool&lt; char &gt;</a></td></tr>
<tr class="memitem:a895359bd08315d7bc32fab5c45933dba inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#a895359bd08315d7bc32fab5c45933dba">MemoryPool</a> (void *begin_address, std::size_t <a class="el" href="class_memory_pool.html#a49ded84ac71c49e1b3c2953c713c9465">pool_size</a>)</td></tr>
<tr class="separator:a895359bd08315d7bc32fab5c45933dba inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaca994267c27f41fae0dfc4ef5a3f42 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="acaca994267c27f41fae0dfc4ef5a3f42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryPool</b> (const <a class="el" href="class_memory_pool.html">MemoryPool</a>&lt; char &gt; &amp;pool)</td></tr>
<tr class="separator:acaca994267c27f41fae0dfc4ef5a3f42 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35156adcccfea1641dcb1d5d61a8280a inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#a35156adcccfea1641dcb1d5d61a8280a">MemoryPool</a> (ContiguousContainer&lt; char &gt; &amp;data)</td></tr>
<tr class="separator:a35156adcccfea1641dcb1d5d61a8280a inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f8886c3bd57d4a3b79cabc9b644bdc inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_pool.html">MemoryPool</a>&lt; char &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#a84f8886c3bd57d4a3b79cabc9b644bdc">operator=</a> (const ContiguousContainer&lt; char &gt; &amp;data)</td></tr>
<tr class="separator:a84f8886c3bd57d4a3b79cabc9b644bdc inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a63c358cb0ab311023c29c5a1ca2ef2 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a1a63c358cb0ab311023c29c5a1ca2ef2"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a1a63c358cb0ab311023c29c5a1ca2ef2 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae149f5b47377070e58e7bbf3b7d68492 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="ae149f5b47377070e58e7bbf3b7d68492"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const</td></tr>
<tr class="separator:ae149f5b47377070e58e7bbf3b7d68492 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724be1ca7f8a4d23347a0ad4f5011b9a inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a724be1ca7f8a4d23347a0ad4f5011b9a"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:a724be1ca7f8a4d23347a0ad4f5011b9a inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7960a77a8830b220e14b165db5e9e47a inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a7960a77a8830b220e14b165db5e9e47a"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const</td></tr>
<tr class="separator:a7960a77a8830b220e14b165db5e9e47a inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6319b8444f07b8e83271a09cf90219 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a2e6319b8444f07b8e83271a09cf90219"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark</b> (std::size_t index, MarkerType mark)</td></tr>
<tr class="separator:a2e6319b8444f07b8e83271a09cf90219 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b30bc1a1413690eca89854a62420f86 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a4b30bc1a1413690eca89854a62420f86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_value</b> (const char &amp;element, MarkerType mark)</td></tr>
<tr class="separator:a4b30bc1a1413690eca89854a62420f86 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ac03840c1141b17c2c31419eebbf48 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="aa2ac03840c1141b17c2c31419eebbf48"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_range</b> (iterator begin, iterator end, MarkerType mark)</td></tr>
<tr class="separator:aa2ac03840c1141b17c2c31419eebbf48 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa287d4df0f44f1e4b80beda958faff inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="adfa287d4df0f44f1e4b80beda958faff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_indices</b> (std::size_t begin_index, std::size_t end_index, MarkerType mark)</td></tr>
<tr class="separator:adfa287d4df0f44f1e4b80beda958faff inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5b8fc191d1b4c19f966f3dd278555f inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="aeb5b8fc191d1b4c19f966f3dd278555f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unmark</b> (std::size_t index)</td></tr>
<tr class="separator:aeb5b8fc191d1b4c19f966f3dd278555f inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387dda98e903bdcf4a0d2bc83d65ae12 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a387dda98e903bdcf4a0d2bc83d65ae12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unmark_value</b> (const char &amp;element)</td></tr>
<tr class="separator:a387dda98e903bdcf4a0d2bc83d65ae12 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9ac173da8973c4ca01c5aafa61b00 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a27d9ac173da8973c4ca01c5aafa61b00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unmark_range</b> (iterator begin, iterator end)</td></tr>
<tr class="separator:a27d9ac173da8973c4ca01c5aafa61b00 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50280ca0fc21f7831345da3daf47fc90 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a50280ca0fc21f7831345da3daf47fc90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unmark_indices</b> (std::size_t begin_index, std::size_t end_index)</td></tr>
<tr class="separator:a50280ca0fc21f7831345da3daf47fc90 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9552af9773138a7c39fdd839de3649b1 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a9552af9773138a7c39fdd839de3649b1"></a>
std::optional&lt; MarkerType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_mark</b> (std::size_t index) const</td></tr>
<tr class="separator:a9552af9773138a7c39fdd839de3649b1 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2495c98cf2c03c7b6a2d2981f2184ed4 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a2495c98cf2c03c7b6a2d2981f2184ed4"></a>
std::optional&lt; MarkerType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_value_mark</b> (const char &amp;element) const</td></tr>
<tr class="separator:a2495c98cf2c03c7b6a2d2981f2184ed4 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e3e623d1bc0d5040822193570df5e0 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a48e3e623d1bc0d5040822193570df5e0"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const</td></tr>
<tr class="separator:a48e3e623d1bc0d5040822193570df5e0 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566fc1aa14e046e37b6d6d51227caaa1 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a566fc1aa14e046e37b6d6d51227caaa1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>null</b> () const</td></tr>
<tr class="separator:a566fc1aa14e046e37b6d6d51227caaa1 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f82adf032131381fa6af43197c307da inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a9f82adf032131381fa6af43197c307da"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>get_address</b> () const</td></tr>
<tr class="separator:a9f82adf032131381fa6af43197c307da inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0728dc146a2fab0bf8db37e5fb461c inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#aae0728dc146a2fab0bf8db37e5fb461c">operator[]</a> (std::size_t index)</td></tr>
<tr class="separator:aae0728dc146a2fab0bf8db37e5fb461c inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf3d8ab3912f2e7b03064925d522335 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top">const char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#a0cf3d8ab3912f2e7b03064925d522335">operator[]</a> (std::size_t index) const</td></tr>
<tr class="separator:a0cf3d8ab3912f2e7b03064925d522335 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73e37a75e8304f5a3f5206f9f7e7cd8 inherit pub_methods_class_memory_pool"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#ad73e37a75e8304f5a3f5206f9f7e7cd8">zero_all</a> ()</td></tr>
<tr class="separator:ad73e37a75e8304f5a3f5206f9f7e7cd8 inherit pub_methods_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_class_pool_marker"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_pool_marker')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_pool_marker.html">PoolMarker&lt; PoolMarking &gt;</a></td></tr>
<tr class="memitem:ad83babff42c4adfce2f0a79a348db3fc inherit pro_types_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="ad83babff42c4adfce2f0a79a348db3fc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MarkerType</b> = PoolMarking</td></tr>
<tr class="separator:ad83babff42c4adfce2f0a79a348db3fc inherit pro_types_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443583379162fa8f3296f677e0860ddd inherit pro_types_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="a443583379162fa8f3296f677e0860ddd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryRegion</b> = std::pair&lt; const void *, const void * &gt;</td></tr>
<tr class="separator:a443583379162fa8f3296f677e0860ddd inherit pro_types_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_pool_marker"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_pool_marker')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_pool_marker.html">PoolMarker&lt; PoolMarking &gt;</a></td></tr>
<tr class="memitem:adcbf1a1af10656252ef822589040a23a inherit pro_methods_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="adcbf1a1af10656252ef822589040a23a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark</b> (MemoryRegion region, PoolMarking marking)</td></tr>
<tr class="separator:adcbf1a1af10656252ef822589040a23a inherit pro_methods_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583802c55db7608a1e2adb358ea1f856 inherit pro_methods_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="a583802c55db7608a1e2adb358ea1f856"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unmark</b> (PoolMarking marking)</td></tr>
<tr class="separator:a583802c55db7608a1e2adb358ea1f856 inherit pro_methods_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1bd054ebcbb2ac5afad59901309a74 inherit pro_methods_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="a9a1bd054ebcbb2ac5afad59901309a74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unmark</b> (MemoryRegion region)</td></tr>
<tr class="separator:a9a1bd054ebcbb2ac5afad59901309a74 inherit pro_methods_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac430b2abea7f923aafef84928a9180 inherit pro_methods_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="a8ac430b2abea7f923aafef84928a9180"></a>
std::optional&lt; PoolMarking &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_mark</b> (const void *address) const</td></tr>
<tr class="separator:a8ac430b2abea7f923aafef84928a9180 inherit pro_methods_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb34911c8a17c9930dd0f75c8d5feca7 inherit pro_methods_class_pool_marker"><td class="memItemLeft" align="right" valign="top"><a id="adb34911c8a17c9930dd0f75c8d5feca7"></a>
std::vector&lt; PoolMarking &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_marks</b> (const MemoryRegion &amp;region) const</td></tr>
<tr class="separator:adb34911c8a17c9930dd0f75c8d5feca7 inherit pro_methods_class_pool_marker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_memory_pool"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_memory_pool')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_memory_pool.html">MemoryPool&lt; char &gt;</a></td></tr>
<tr class="memitem:a708d6c03ba13e58375d7a8e863ede1f3 inherit pro_attribs_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a708d6c03ba13e58375d7a8e863ede1f3"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#a708d6c03ba13e58375d7a8e863ede1f3">first</a></td></tr>
<tr class="memdesc:a708d6c03ba13e58375d7a8e863ede1f3 inherit pro_attribs_class_memory_pool"><td class="mdescLeft">&#160;</td><td class="mdescRight">First address in the pool. <br /></td></tr>
<tr class="separator:a708d6c03ba13e58375d7a8e863ede1f3 inherit pro_attribs_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9721e8ad10d9b79986cd942f838e17e inherit pro_attribs_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="aa9721e8ad10d9b79986cd942f838e17e"></a>
char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#aa9721e8ad10d9b79986cd942f838e17e">last</a></td></tr>
<tr class="memdesc:aa9721e8ad10d9b79986cd942f838e17e inherit pro_attribs_class_memory_pool"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last address in the pool. <br /></td></tr>
<tr class="separator:aa9721e8ad10d9b79986cd942f838e17e inherit pro_attribs_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ded84ac71c49e1b3c2953c713c9465 inherit pro_attribs_class_memory_pool"><td class="memItemLeft" align="right" valign="top"><a id="a49ded84ac71c49e1b3c2953c713c9465"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_pool.html#a49ded84ac71c49e1b3c2953c713c9465">pool_size</a></td></tr>
<tr class="memdesc:a49ded84ac71c49e1b3c2953c713c9465 inherit pro_attribs_class_memory_pool"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements available in the pool. <br /></td></tr>
<tr class="separator:a49ded84ac71c49e1b3c2953c713c9465 inherit pro_attribs_class_memory_pool"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... Ts&gt;<br />
class StaticVariadicMemoryPool&lt; Ts &gt;</h3>

<p>Like a <a class="el" href="class_memory_pool.html">MemoryPool</a>, but the size and composition of the pool is known at compile-time, due to the template parameter pack arguments. This is essentially an std::tuple which assumes that the memory is pre-allocated. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>- Type order in the pool, just like an std::tuple </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bbaf21d16cdced110707a0fb6a41f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbaf21d16cdced110707a0fb6a41f2e">&#9670;&nbsp;</a></span>StaticVariadicMemoryPool() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::<a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>begin_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an SVMPool at the given address. Note: It is assumed that the memory region beginning at this address is preallocated, of size at least totalling the total sizeof the parameter pack. If not, attempting to access this pool will invoke UB. Note: This will not attempt to default or zero the existing memory. This is achieved by methods. It is your responsibility to track which elements are garbage memory or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_address</td><td>- Address for this pool to manage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0b66977eae1b5bc6b6889f4c64e5820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b66977eae1b5bc6b6889f4c64e5820">&#9670;&nbsp;</a></span>StaticVariadicMemoryPool() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::<a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>begin_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an SVMPool at the given address. Following that, write the given parameter values to the pool. Note: It is assumed that the memory region beginning at this address is preallocated, of size at least totalling the total sizeof the parameter pack. If not, attempting to access this pool will invoke UB. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_address</td><td>- Address for this pool to manage </td></tr>
    <tr><td class="paramname">ts</td><td>- Parameter arguments to populate the memory pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac010baab2637d50167fa5214144f7e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac010baab2637d50167fa5214144f7e42">&#9670;&nbsp;</a></span>StaticVariadicMemoryPool() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::<a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_pool.html">MemoryPool</a>&lt; char &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fixed_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an SVMPool wrapping around an existing byte pool. Note: It is assumed that the byte capacity of the byte pool is equal to the size totalling the parameter pack. If this is not the case, an assertion will fail (Or invoke UB in Release). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed_pool</td><td>- <a class="el" href="class_memory_pool.html">MemoryPool</a> to wrap around </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aab894571bf1bf451c29bf7e126464ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab894571bf1bf451c29bf7e126464ced">&#9670;&nbsp;</a></span>default_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::default_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the pool, resetting each element to its default value. Note: This will fail to compile if at least one type in the parameter pack is not default constructible. </p>

<p>Reimplemented from <a class="el" href="class_memory_pool.html#a3fee86cb9037b20a415f0ee1219addc4">MemoryPool&lt; char &gt;</a>.</p>

</div>
</div>
<a id="a6a2ea1c545181881655a5a458b4d06f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2ea1c545181881655a5a458b4d06f3">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the given type value in the pool. Note: This will fail to compile in the case that duplicate types exist in the pool. Note: To access an SVMPool with duplicate types, use SVMPool&lt;Ts...&gt;::get&lt;std::size_t I&gt;(). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the pool element to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Value corresponding to the given type in the pool </dd></dl>

</div>
</div>
<a id="ac25f9e983bf8e848639cc1ff930931f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f9e983bf8e848639cc1ff930931f7">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;std::size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value at the given index in the pool, whatever its type may be. Note: This will fail to compile if the index is out of range. Example: SVMPool&lt;float, int, char&gt;::get&lt;0&gt;() will return a value of type float. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>- Index of the value to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Value at the given index </dd></dl>

</div>
</div>
<a id="a6b3dffd4a8e3cdbeba182da764aab34c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3dffd4a8e3cdbeba182da764aab34c">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the given type value in the pool. Note: This will fail to compile in the case that duplicate types exist in the pool. Note: To access an SVMPool with duplicate types, use SVMPool&lt;Ts...&gt;::get&lt;std::size_t I&gt;(). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>- Type of the pool element to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Value corresponding to the given type in the pool </dd></dl>

</div>
</div>
<a id="a43d648156035bdbabba39a07f52c453c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d648156035bdbabba39a07f52c453c">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;std::size_t I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value at the given index in the pool, whatever its type may be. Note: This will fail to compile if the index is out of range. Example: SVMPool&lt;float, int, char&gt;::get&lt;0&gt;() will return a value of type float. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>- Index of the value to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Value at the given index </dd></dl>

</div>
</div>
<a id="acc9aa94210059568bdeef86a62b4da88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9aa94210059568bdeef86a62b4da88">&#9670;&nbsp;</a></span>get_byte_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::get_byte_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of bytes available in the pool. For an SVMPool, this is always equal to the total size of every element in the parameter pack. </p><dl class="section return"><dt>Returns</dt><dd>- Capacity of the pool, in bytes </dd></dl>

<p>Reimplemented from <a class="el" href="class_memory_pool.html#a1e284e0c6bf170064fca389ee24a9ec3">MemoryPool&lt; char &gt;</a>.</p>

</div>
</div>
<a id="a6859bc07dbe1955f410b351838f76679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6859bc07dbe1955f410b351838f76679">&#9670;&nbsp;</a></span>get_element_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="class_static_variadic_memory_pool.html">StaticVariadicMemoryPool</a>&lt; Ts &gt;::get_element_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of elements available in the pool. For an SVMPool, this is always equal to the number of elements in the parameter pack. </p><dl class="section return"><dt>Returns</dt><dd>- Number of elements in the parameter pack </dd></dl>

<p>Reimplemented from <a class="el" href="class_memory_pool.html#a5f1dd31da06a068f49b4035dc5ca2213">MemoryPool&lt; char &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/utility/<a class="el" href="memory_8hpp_source.html">memory.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
